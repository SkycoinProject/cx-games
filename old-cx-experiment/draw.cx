
func All() () {
	
	// test circles 

	x, y := game.GetPosOfPerfectRadiusVisualizer()
	//AimedPerFrameTriangle(x, y, 0.09, entity.CurrDebugRocketAim, 1.0, 0.0, 0.0)
	//Circle(x, y, 0.07, 1.0, 0.0, 0.0)
	Polygon(1, x, y, 0.07, 1.0, 0.0, 0.0)

	//x, y := game.GetPosOfBoxyDistanceVisualizer()
	//Circle(x, y, 0.07, 0.0, 1.0, 0.0)
	//Polygon(1, x, y, 0.07, 0.0, 1.0, 0.0)
	


	// draw debug missile in middle of screen, ignoring "camera" pos 
	//[]f32.write(entity.X, 1, 0.0)
	//[]f32.write(entity.Y, 1, 0.0)
	cameraIgnoringPolygon(1, 0.0, 0.0, 1.8, 1.0, 1.0, 1.0)

	/* draw */ //circlesAtPathEdgePoints()
	/* draw */ menuMaybe()
	/* draw */ Snake()
	/* draw */ Entities()
	/* draw */ path()
	/* draw */ eventText()
	/* draw */ maybeHelpText()
	
	// moves with player 
	//EntityAttachedText([]f32.read(entity.X, 0), []f32.read(entity.Y, 0), 0.0, 0.0, s)
}


func circlesAtPathEdgePoints() () {
	rad := 0.01

	id := 0 // of node 

	// 1st string all lefts together 
	for game.PathNodeExists(id) {
		lX, lY := game.GetLeftVertexFor(id)
		Circle(lX, lY, rad, 0.8, 0.8, 0.8)
		id++
	}



	id--

	// now string all rights together, going from tip of tail, back to root/head 
	for game.PathNodeExists(id) {
		rX, rY := game.GetRightVertexFor(id)
		Circle(rX, rY, rad, 0.8, 0.8, 0.8)
		id--
	}
}


func path() () {
	red   = 0.2
	green = 0.4
	blue  = 0.7
	dimming = false

	// player pos 
	pX := []f32.read(entity.X, 0)
	pY := []f32.read(entity.Y, 0)

	id := 0 // of node 
	for game.PathNodeExists(id) {
		//str.print("path node:")
		//i32.print(id)

		gl.Begin(gl.POLYGON)
		gl.Color3f(red, green, blue)

		// near & far verts (L & R) 
		nLX, nLY, 
		nRX, nRY,
		fLX, fLY, 
		fRX, fRY := game.Get4NodeVertices(id)
		gl.Vertex2f(nLX - pX, nLY - pY)	
		gl.Vertex2f(nRX - pX, nRY - pY)	
		gl.Vertex2f(fLX - pX, fLY - pY)	
		gl.Vertex2f(fRX - pX, fRY - pY)

		gl.End()

		setNodeColor()
		id++
	}
}


func setNodeColor() () {
	ccd /* color channel delta */ := 0.05
	if dimming {
		ccd = 0.0 - ccd
	}

	red   += ccd
	green += ccd

	// maybe toggle dimming/brightening flag 
	if dimming {
		if red < 0.0 && green < 0.0 {
			dimming = false
		}
	} else {
		if red > 1.0 && green > 1.0 {
			dimming = true
		}
	}
}


func Entities() () {
	// skipping 0 (reserved for player entity), which has it's own draw func. 

	for i := 1; i < []f32.len(entity.X); i++ {
		if entity.IsAlive(i) {
			Polygon(
				i, 
				[]f32.read(entity.X, i),
				[]f32.read(entity.Y, i),
				[]f32.read(entity.Rad, i),
				[]f32.read(entity.Red, i), 
				[]f32.read(entity.Green, i), 
				[]f32.read(entity.Blue, i))
		}
	}
}


func cameraIgnoringPolygon(id i32, x f32, y f32, radius f32, red f32, green f32, blue f32) () {
	gl.Begin(gl.POLYGON)
	gl.Color3f(red, green, blue)
	
	num   := []i32.read(entity.NumVertices, id)
	start := []i32.read(entity.FirstVertex, id)

	for i := start; i < start + num; i++ {
		xx := radius * []f32.read(entity.VertexSoupX, i)
		yy := radius * []f32.read(entity.VertexSoupY, i)		

		gl.Vertex2f(xx, yy)
	}

	gl.End()
}


func Polygon(entityId i32, x f32, y f32, radius f32, red f32, green f32, blue f32) () {
	// base "camera" on player/snake 
	x -= []f32.read(entity.X, entity.SnakeId)
	y -= []f32.read(entity.Y, entity.SnakeId)



	gl.Begin(gl.POLYGON)
	gl.Color3f(red, green, blue)
	


	start := []i32.read(entity.FirstVertex, entityId)
	num   := []i32.read(entity.NumVertices, entityId)

	for i := start; i < start + num; i++ { // i == vertex id 
		gl.Vertex2f(
			x + []f32.read(entity.VertexSoupX, i), 
			y + []f32.read(entity.VertexSoupY, i))
	}



	gl.End()



	str.print("just drew Polygon() with (what could be completely unsynced from vertices) entity.[entityId]Aim:")
	f32.print([]f32.read(entity.Aim, entityId))
}


func Rect(top f32, right f32, bottom f32, left f32, red f32, green f32, blue f32) () {
	gl.Begin(gl.POLYGON)

	gl.Color3f(red, green, blue)
	
	gl.Vertex2f(right, top)	
	gl.Vertex2f(right, bottom)

	div := 3.0 // horizontal gradient divisor 
	gl.Color3f(red/div, green/div, blue/div)

	gl.Vertex2f(left,  bottom)
	gl.Vertex2f(left,  top)

	gl.End()
}


func Circle(x f32, y f32, radius f32, red f32, green f32, blue f32) () {
	gl.Begin(gl.POLYGON)
	gl.Color3f(red, green, blue)

	
	for i := 0; i < game.NumCircleLUTPoints; i++ {
		gl.Vertex2f(
			x + radius * []f32.read(game.CirclePointsX, i),
			y + radius * []f32.read(game.CirclePointsY, i))
	}

	gl.End()
}


func aimedYetDecimatedCircleApproximation(
	step i32, // the stride thru indices (decimates game.NumCircleLUTPoints, for lower resolution) 
	x f32, 
	y f32, 
	radius f32, 
	angle f32, 
	red f32, green f32, blue f32) () {

	//
	//
	// potentially doesn't add vertices 



	gl.Begin(gl.POLYGON)
	gl.Color3f(red, green, blue)

	// insane number (goes outside of valid index range, requires sanitizing)
	startIdx := 0
	if game.CirclePointsAngleIncrement > 0.0 {
		startIdx = f32.i32(angle / game.CirclePointsAngleIncrement)
	}

	// (FIXME if perfection is needed later... should "round" instead of
	// effectively "floor"ing, which means subtracting half a radian grain?) 
	max := game.NumCircleLUTPoints + startIdx

	for i := startIdx; i < max; i += step {
		si := i // sane index 

		for si >= game.NumCircleLUTPoints {
			si -= game.NumCircleLUTPoints
		}

		gl.Vertex2f(
			x + radius * []f32.read(game.CirclePointsX, si),
			y + radius * []f32.read(game.CirclePointsY, si))
	}

	gl.End()
}


func AimedPerFrameTriangle(x f32, y f32, radius f32, angle f32, red f32, green f32, blue f32) () {
	gl.Begin(gl.POLYGON)
	gl.Color3f(red, green, blue)

	aX := radius * f32.sin(angle)
	aY := radius * f32.cos(angle)
	bX := radius * f32.sin(angle + game.ThirdOf360)
	bY := radius * f32.cos(angle + game.ThirdOf360)
	cX := radius * f32.sin(angle + game.TwoThirdsOf360)
	cY := radius * f32.cos(angle + game.TwoThirdsOf360)

	gl.Vertex2f(x + aX, y + aY)
	gl.Vertex2f(x + bX, y + bY)
	gl.Vertex2f(x + cX, y + cY)

	gl.End()
}


func Snake() () {
	sin := f32.sin(game.CurrSnakeAim)
	cos := f32.cos(game.CurrSnakeAim) 

	// head/tail deltas (from center of snake) 
	xOff := game.CurrSnakeExtent * sin
	yOff := game.CurrSnakeExtent * cos
	
	// center pos 
	cX := 0.0 // []f32.read(entity.X, entity.SnakeId)
	cY := 0.0 // []f32.read(entity.Y, entity.SnakeId)

	// tail pos 
	tX := cX - xOff
	tY := cY - yOff

	// head pos 
	hX := cX + xOff
	hY := cY + yOff
	


	entity.SetupChainFromAToB(
		// tail 
		tX, 
		tY, 
		game.TailRadius, 

		// head 
		hX, 
		hY, 
		game.HeadRadius,

		true)

	// draw head 
	//Circle(entity.BX, entity.BY, game.HeadRadius, 0.0, 0.0, 1.0)
	AimedPerFrameTriangle(entity.BX, entity.BY, game.HeadRadius, game.CurrSnakeAim, 0.0, 0.0, 1.0)

	drawDirectionalInputIndicators(sin, cos)

	// draw rotation (center hinge) point 
	Circle(cX, cY, game.HeadRadius / 3.0, 0.0, 0.0, 1.0)



	// draw most segments of snake's body 

	for entity.ChainProgress <= entity.ChainLength {
		// fraction towards destination 
		ftd := entity.ChainProgress / entity.ChainLength
		
		// current radius 
		cRad := game.TailRadius + ftd * entity.DelRad

		aimedYetDecimatedCircleApproximation(
			5,
			tX + ftd * entity.DelX, 
			tY + ftd * entity.DelY, 
			cRad, 
			game.CurrSnakeAim,
			0.0, 0.0, 0.0)

		entity.AdvanceChainProgressBy(cRad)
	}
}


func eventText() () { // .... @ top of screen 
	if game.EventTextTimeFadeStarts != 0.0 && // (text has expiry set &...) 
		game.EventTextIntensity > 0.0 {       // (...still has some color intensity) 

		gl.Color4f(
			game.EventTextIntensity, 
			0.0, //game.EventTextIntensity, // now magenta (was white) 
			game.EventTextIntensity, 
			1.0)

		CcText(
			game.EventTextX,
			game.EventTextY, 
			game.EventText)

		//gltext.Printf("Roboto100", 0.0, 0.0, "Hello World")
	}
}
