



// chain of entities (singleton) 
// (used to plot a variable amount of circles from point A to point B)
var ChainLength f32 // distance between end/A/B points 
var ChainProgress f32 // current fraction along chain's length (0.0 - 1.0) 

//			points 
var /* point  */ AX   f32
var /* point  */ AY   f32
var /* radius */ ARad f32

var /* point  */ BX   f32
var /* point  */ BY   f32
var /* radius */ BRad f32

//			deltas from point A to point B 
var DelX   f32
var DelY   f32
var DelRad f32



func Init() () {
	str.print("--- entity.Init()")

	// screen space ranges from -1.0 to 1.0 
	pixelSpan = 2.0 / i32.f32(game.ScreenNumPixelsHigh)
	gradientSpan = 1.0 / 300.0

	SpawnMap()
}


var CurrDebugRocketAim f32

var prevNumLastingEnts i32 = 0
var prevFrame f32 = 0.0
func Update() () {
	currNumLastingEnts := 0
 	currFrame   = f64.f32(glfw.GetTime())
 	deltaFrame := currFrame - prevFrame
 	mm          = deltaFrame * 200.0
 	velocityInc = deltaFrame / 50.0

	// per frame...
	for i := 0; i < []f32.len(X); i++ {
		// ...per relevant entity 
		if IsAlive(i) {
			if isLasting(i) {
				currNumLastingEnts++;
			}

			// movement 
			vx := []f32.read(VelX, i) 
			vy := []f32.read(VelY, i)

			if /* moving */ vx != 0.0 || vy != 0.0 {
				// old spot 
				oX := []f32.read(X, i)
				oY := []f32.read(Y, i)

				// new spot 
				delX := vx * mm
				delY := vy * mm
				nX := oX + delX
				nY := oY + delY
				boxyDist := []f32.read(BoxyDistance, i)
				boxyDel  := f32.abs(delX) + f32.abs(delY)
				[]f32.write(BoxyDistance, i, boxyDist + boxyDel)

				// detect collision before potential screen wrapping teleport. 
				// because a screen spanning delta makes no sense for collision 
				//SetupChainFromAToB(
				//	oX, oY, []f32.read(Rad, i),
				//	nX, nY, []f32.read(Rad, i), false)
				IsTouching_WillExplode(i, boxyDel > []f32.read(Rad, i))
				updatePosition(nX, nY, i)
			}
		} else { // dead 
			if /* died THIS frame */ []i32.read(PrevAliveStatus, i) == isTrue {
				[]i32.write(PrevAliveStatus, i, isFalse)

				//if []i32.read(EntityType, i) == ENT_TYPE_Missile {
				if []i32.read(EntityType, i) == ENT_TYPE_Bullet {
					makeMissile()
				}
			}
		}
	}

	// just detecting when a stage is finished 
	// (player/snake would generally be alive here) 
	// (moment of expiry (state change) prob will be handled elsewhere) 
	
	if currNumLastingEnts != prevNumLastingEnts &&
		currNumLastingEnts <= 1 {
		
		numEnts++
		game.SetStage(game.Stage + 1);
	}




	fv := []i32.read(FirstVertex, 1)
	setupAimedTriangle(fv, 0.5, CurrDebugRocketAim)
	//setupMissilePoly(fv, CurrDebugRocketAim)
	CurrDebugRocketAim += 0.07
	str.print("entity.Update()   -   CurrDebugRocketAim:")
	f32.print(CurrDebugRocketAim)








	prevNumLastingEnts = currNumLastingEnts
	prevFrame = currFrame
}


func SpawnMap() () {
	// MAKE PLAYER 

	// len(X) is count of entities 
	if /* 1st map/stage/wave */ []f32.len(X) == 0 {
		// make everpresent snake entity 
		initVel := 0.0 //0.009 (with current choppy FPS, don't want to jerk whole screen) 
		SpawnEntity(
			ENT_TYPE_Player,
			0.0, 0.0, 
			initVel, initVel, 
			0.0, // aim   FIXME (get rid of separate CurrSnakeAim variable?) 
			game.MaxSnakeExtent, 
			/* expiries */ 0.0, 0.0, 
			/* collidable */ false)
	}

	// MAKE MISSILES 
	for i := 1; i < numEnts; i++ {
		makeMissile()
	}

	str.print("SpawnMap(): DONE")
}


func makeMissile() () {
	missileRad := 0.0013

	//vx, vy := getRandomVelocities()
	x, y, velX, velY, aim, thExtent := getPosAimAndDistFromRandomTrackNode()
	str.print("from getPosAimAndDistFromRandomTrackNode got [aim]:")
	f32.print(aim)

	SpawnEntity(
		ENT_TYPE_Bullet, // or should it be debris? 
		//ENT_TYPE_Missile,
		x, y,
		velX, velY,
		0.0, //aim,
		missileRad, 
		/* expiries */ 0.0, thExtent, 
		/* collidable */ true)
}


var nonRandomNodeForDebug_Id i32
func getPosAimAndDistFromRandomTrackNode() (x f32, y f32, aimX f32, aimY f32, aim f32, dist f32) {
	fractionForVelocity := 0.0004
	rndIdx := nonRandomNodeForDebug_Id //i32.rand(0, 7) //cavern.NumNodes)
	
	    nonRandomNodeForDebug_Id++
	if 	nonRandomNodeForDebug_Id >= cavern.NumNodes {
		nonRandomNodeForDebug_Id = 0
	}
	
	aim = []f32.read(cavern.Aim, rndIdx)
	//if i32.rand(0, 2) == 0 {
		x,    y    = game.GetLeftVertexFor(rndIdx)
		aimX, aimY = game.GetRightVertexFor(rndIdx)
		//aim += game.HalfPi
	//} else {
	//	x,    y    = game.GetRightVertexFor(rndIdx)
	//	aimX, aimY = game.GetLeftVertexFor(rndIdx)
	//	aim -= game.HalfPi
	//}

	aimX -= x
	aimY -= y

	return 
		x, 
		y, 
		aimX * fractionForVelocity, 
		aimY * fractionForVelocity,
		aim,
		game.GetThickExtentFor(rndIdx) * 2.0
}


func SetupChainFromAToB(
	aX f32, aY f32, aRad f32, 
	bX f32, bY f32, bRad f32,
	isSnakeEntity bool) () {

	AX = aX;
	AY = aY;
	ARad = aRad;
	BX = bX
	BY = bY
	BRad = bRad

	DelX := bX - aX 
	DelY := bY - aY
	DelRad := bRad - aRad



	// overlap circles by about half their radius.		
	ChainProgress = 0.0 // current spot in distance spectrum (0.0 - 1.0) 
	
	if isSnakeEntity {
		ChainLength = game.CurrSnakeExtent * 2.0
	} else {
		ChainLength = game.GetDistance(aX, aY, bX, bY)
	}
}


func AdvanceChainProgressBy(inc f32) () {
	ChainProgress += inc
}
