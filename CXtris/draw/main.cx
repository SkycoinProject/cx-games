package main



var HackyHeightFraction f32 = 0.61458333333



func drawInit () {
	str.print("drawInit ()")
	
	// THE (MORE PROPER) CALCULATION BELOW, DOESN'T WORK FOR SOME REASON, 
	// SO......HARDWIRED VALUE AT DECLARATION (FIXME when CX FIXES THIS) 
	//HackyHeightFraction = f32.div(i32.f32(app.START_WIDTH), i32.f32(app.START_HEIGHT))

	draw.InitPics()
	InitControlsText()
}


func drawAll () {
	//gl.Clear(gl.COLOR_BUFFER_BIT)
	gl.Clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT) // gltext needs 
		
	//gl.MatrixMode(gl.PROJECTION)
	//gl.LoadIdentity()
	//gl.MatrixMode(gl.MODELVIEW)

	gl.Color3f(1.0, 1.0, 1.0)
	draw.ScaledPic(draw.PicBackground, 0.0, 0.0, 2.0, 2.0)
	PlayField()
	PlayerPiece()

	if ShowNextShape {
		NextShape()
	}
	
	if app.Mode < app.MODE_MENU_MAX { // in a menu 
		menu.DrawRects()
		
		if app.Mode == app.MODE_MENU_CONTROLS {
			drawVirtualKeyBackdrops()
		}
	}else
	if app.Mode == app.MODE_PLAYING {
		if gui.ShowControls {
			drawVirtualKeyBackdrops()
		}
	}
	
	// cursor/pointer 
	draw.ScaledPic(draw.PicStar, 
		inputs.MousePointer.X,
		inputs.MousePointer.Y, 
		0.1  * 0.3, 
		0.07 * 0.3)
	
	gl.LoadIdentity()
	allText()
}


func PlayField () {
	var fX f32 = map.LEdge + map.CellWidthHalf
	var fY f32 =     -0.95 + map.CellHeightHalf

	for     y := 0; y < map.NUM_CELLS_Y; y++ {
		for x := 0; x < map.NUM_CELLS_X; x++ {
			var c i32 = map.Cells[y][x]

			if c == map.EMPTY_CELL {
				c = shape.SHAPE_MAX
			}
			
			gl.Color3f(
				draw.Colors[c].R, 
				draw.Colors[c].G, 
				draw.Colors[c].B)
			
			draw.ScaledPic(
				draw.PicShapeTile, 
				f32.add(fX, f32.mul(i32.f32(x), map.CellWidth)),
				f32.add(fY, f32.mul(i32.f32(y), map.CellHeight)), 
				map.CellWidth, 
				map.CellHeight)
		}
	}
}


func PlayerPiece () {
	var fX   f32 = map.LEdge + map.CellWidthHalf
	var fY   f32 =     -0.95 + map.CellHeightHalf
	var del  f64 = CurrTime - shape.PlayerMoveTime
	var offs f32
	
	if del < 0.2D {
		offs = f64.f32(del / 0.2D) * map.CellHeight
		offs = offs - map.CellHeight
	}else{
		offs = 0.0
	}
				
	gl.Color3f(
		draw.Colors[shape.PlayerShape].R, 
		draw.Colors[shape.PlayerShape].G, 
		draw.Colors[shape.PlayerShape].B)
	
	for     y := 0; y < 5; y++ {
		for x := 0; x < 5; x++ {
			if shape.Cells[shape.PlayerShape][shape.PlayerFacing][y][x] {
				draw.ScaledPic(
					draw.PicShapeTile, 
					f32.add(fX, f32.mul(i32.f32(x - 2 + shape.PlayerPos.X), map.CellWidth)),
					f32.add(fY, f32.mul(i32.f32(y - 2 + shape.PlayerPos.Y), map.CellHeight)) - offs,
					map.CellWidth, 
					map.CellHeight)
			}
		}
	}
}


func NextShape () {
	gl.Color3f(
		draw.Colors[shape.Next].R, 
		draw.Colors[shape.Next].G, 
		draw.Colors[shape.Next].B)
	
	var fX f32 = shape.StartPosX
	var fY f32 = shape.StartPosY
	
	for y := shape.StartY; y < 5; y++ {
		for x := shape.StartX; x < 5; x++ {
			if shape.Cells[shape.Next][shape.FACING_UP][y][x] {
				draw.ScaledPic(
					draw.PicShapeTile, 
					fX,
					fY, 
					shape.NextCellSpanX, 
					shape.NextCellSpanY)
			}
			
			fX = f32.add(fX, shape.NextCellSpanX)
		}
		
		fX = shape.StartPosX
		fY = f32.add(fY, shape.NextCellSpanY)
	}
}
