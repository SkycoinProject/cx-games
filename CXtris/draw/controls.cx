package main

import "draw"



// FIXME when CX has constants 
var NUM_H_KEYS   i32 = 3 // horizontal 
var NUM_V_KEYS   i32 = 2 // vertical 
var SPAN         f32 = 2.0 / i32.f32(NUM_H_KEYS)
var SPAN_HALF    f32 = SPAN / 2.0
var SPAN_QUARTER f32 = SPAN / 3.4//4.0
var SPAN_HALF_V  f32 // vertical 
// pixel space 
var psSpan     f32
var psSpanHalf f32
var pixMargin  f32

// controls text 
var keySetPri []draw.TextGL // primary 
var keySetSec []draw.TextGL // secondary 



func InitControlsText () {
	// couldn't do next bits of math @ declaration 
	//		gl space 
	SPAN_HALF_V  = SPAN_HALF * HackyHeightFraction
	// 		pixel space 
	psSpan     = f32.div(i32.f32(app.START_WIDTH), 3.0)
	psSpanHalf = psSpan / 2.0
	str.print("psSpan:")
	f32.print(psSpan)

	keySetPri = append(
	keySetPri, getNewText("A"))
	keySetPri = append(
	keySetPri, getNewText("S"))
	keySetPri = append(
	keySetPri, getNewText("D"))
	keySetPri = append(
	keySetPri, getNewText("Q"))
	keySetPri = append(
	keySetPri, getNewText("E"))

	keySetSec = append(
	keySetSec, getNewText("<-"))
	keySetSec = append(
	keySetSec, getNewText("V"))
	keySetSec = append(
	keySetSec, getNewText("->"))
	keySetSec = append(
	keySetSec, getNewText("Ctrl/Alt"))
	keySetSec = append(
	keySetSec, getNewText("Alt/Ctrl"))

	// precalc positions 
	initKeySet(false)
	initKeySet(true)
}


func getNewText (key str) (out draw.TextGL) {
	out = draw.TextGL{ Text: key, Size: 28.0 }
}


func initKeySet (yOffset bool) {
	var keySet []draw.TextGL
	
	if yOffset {
		keySet = keySetSec
	}else{
		keySet = keySetPri	
	}
	
	var w i32
	var h i32
	var x f32
	var y f32 = i32.f32(app.START_HEIGHT)
	
	for i := 0; i < len(keySet); i++ {
		str.print(keySet[i].Text)



		var font str = str.concat("Roboto", sprintf("%d", f32.i32(keySet[i].Size)))
		printf("font: %s \n", font)
		keySet[i].FontId = font		
		w, h = gltext.Metrics(font, 
		keySet[i].Text)
		printf("keySet[i].Text: %s \n", keySet[i].Text)
		keySet[i].Wid = i32.f32(w)
		keySet[i].Hei = i32.f32(h)
		y = f32.sub(y,  i32.f32(h))
		//printf("NEW Y IS: %f \n", y)
		keySet[i].Top = y
		keySet[i].Left = x //(i32.f32(app.START_WIDTH) - keySet[i].Wid) / 2.0


		// increment virtual text "cursor" 
		if i == 2 {
			x = 0.0
			//y = y - psSpan
		}else
		if i == 3 {
			x = x + psSpan
			x = x + psSpan
		}else{
			x = x + psSpan
		}
	}
}


func drawKeyCapTexts () {
	draw.SetColor3(draw.Black)
	
	var y f32 = i32.f32(app.START_HEIGHT) - psSpan
	
	for i := 0; i < len(keySetPri); i++ {
		var xo f32 // x offset 

		// primary set 
		xo = getXOffset(i, 
			keySetPri[i].Wid)
		gltext.Printf(
			keySetPri[i].FontId, 
			keySetPri[i].Left + xo, 
			y,
			keySetPri[i].Text)
			
		// secondary set 
		xo = getXOffset(i, 
			keySetSec[i].Wid)
		gltext.Printf(
			keySetSec[i].FontId, 
			keySetSec[i].Left + xo, 
			y + keySetSec[i].Hei,
			keySetSec[i].Text)


		// increment virtual text "cursor" 
		if i == 2 {
			y = y - psSpan
		}
	}
}


func getXOffset(i i32, wid f32) (xo f32) {
	// set horizontal alignment to left or right edge of keycap 
	if i == 2 || // (align right) 
		i == 4 {
			
		xo = psSpan - wid - pixMargin
	}else{       // (align left) 
		xo = pixMargin
	}
}


func drawVirtualKeyBackdrops () {
	//"mouse" icon/s needed 
	//"mouse" icon/s needed 
	//"mouse" icon/s needed 

	if app.Mode == app.MODE_PLAYING {
		draw.SetColor4(draw.White, 0.8)
	}else{
		draw.SetColor3(draw.White)
	}
	var x f32 = -1.0 + SPAN_HALF
	var y f32 = -1.0 + SPAN_HALF_V
	
	// bottom 3 
	for i := 0; i < NUM_H_KEYS; i++ {
		draw.ScaledPic(draw.PicShapeTile, 
			x,
			y, 
			SPAN, 
			SPAN * HackyHeightFraction)

		if i == 0 {
			draw.ScaledPic(draw.PicArrowLeft, 
				x,
				y, 
				SPAN_HALF, 
				SPAN_HALF_V)
			draw.ScaledPic(draw.PicMouse, 
				x + SPAN_QUARTER,
				y, 
				SPAN_QUARTER, 
				SPAN_QUARTER)			
		}else			
		if i == 1 {
			draw.ScaledPic(draw.PicArrowDown, 
				x,
				y, 
				SPAN_HALF, 
				SPAN_HALF_V)
			draw.ScaledPic(draw.PicMouse, 
				x,
				y + SPAN_QUARTER, 
				SPAN_QUARTER, 
				SPAN_QUARTER)			
		}else			
		if i == 2 {
			draw.ScaledPic(draw.PicArrowRight, 
				x,
				y, 
				SPAN_HALF, 
				SPAN_HALF_V)
			draw.ScaledPic(draw.PicMouse, 
				x - SPAN_QUARTER,
				y, 
				SPAN_QUARTER, 
				SPAN_QUARTER)			
		}
				
		x = f32.add(x, SPAN)
	}
	
	
	x = -1.0 + SPAN_HALF
	y = f32.add(y, SPAN * HackyHeightFraction)


	// top left 
	draw.ScaledPic(draw.PicShapeTile, 
		x,
		y, 
		SPAN, 
		SPAN * HackyHeightFraction)
	draw.ScaledPic(draw.PicRotLeft, 
		x,
		y, 
		SPAN_HALF, 
		SPAN_HALF_V)
	draw.ScaledPic(draw.PicMouseLMB, 
		x + SPAN_QUARTER,
		y, 
		SPAN_QUARTER, 
		SPAN_QUARTER)			


	x = f32.add(x, SPAN * 2.0)

	
	// top right 
	draw.ScaledPic(draw.PicShapeTile, 
		x,
		y, 
		SPAN, 
		SPAN * HackyHeightFraction)
	draw.ScaledPic(draw.PicRotRight, 
		x,
		y, 
		SPAN_HALF, 
		SPAN_HALF_V)
	draw.ScaledPic(draw.PicMouseRMB, 
		x - SPAN_QUARTER,
		y, 
		SPAN_QUARTER, 
		SPAN_QUARTER)			
}