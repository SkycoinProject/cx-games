package gameDraw



// FIXME when CX has constants 
var NUM_H_KEYS   i32 = 3 // horizontal 
var NUM_V_KEYS   i32 = 2 // vertical 
var SPAN         f32 = 2.0 / i32.f32(NUM_H_KEYS)
var SPAN_HALF    f32 = SPAN / 2.0
var SPAN_QUARTER f32 = SPAN / 3.4//4.0
var SPAN_HALF_V  f32 // vertical 

// controls text 
var keySetPri []TextGL //...ary 
var keySetSec []TextGL //...ondary 



func InitControlsText () {
	// couldn't do next bit of math in the declaration 
	SPAN_HALF_V = SPAN_HALF * map.HackyHeightFraction

	keySetPri = append(
	keySetPri, getNewText("A"))
	keySetPri = append(
	keySetPri, getNewText("S"))
	keySetPri = append(
	keySetPri, getNewText("D"))
	keySetPri = append(
	keySetPri, getNewText("Q"))
	keySetPri = append(
	keySetPri, getNewText("E"))

	/*
	newKey(keySetSec, "<-")
	newKey(keySetSec, "V")
	newKey(keySetSec, "->")
	newKey(keySetSec, "Ctrl/Alt")
	newKey(keySetSec, "Alt/Ctrl")
	*/
	
	// precalc positions 
	initKeySet(keySetPri, false)
	//initKeySet(keySetSec, true)
}


func getNewText (key str) (out TextGL) {
	out = TextGL{ Text: key, Size: 28.0 }
}


func drawKeyCapTexts () {
	var pixHSpan     f32 = i32.f32(app.START_WIDTH) / 3.0
	var pixHSpanHalf f32 = pixHSpan / 2.0
	var margin       f32 = pixHSpan / 5.0
	var x f32
	var y f32 = i32.f32(app.START_HEIGHT) - pixHSpan
	
	for i := 0; i < len(keySetPri); i++ {
		// set horizontal alignment to left or right edge of keycap 
		var xo f32 // x offset 
		
		if i == 2 || // (align right) 
			i == 4 {
				
			xo = pixHSpan - keySetPri[i].Wid - margin
		}else{ // (align left) 
			xo = margin
		}
		
		
		draw.SetColor3(draw.Black)
		gltext.Printf(
			keySetPri[i].FontId, 
			x + xo, 
			y,
			keySetPri[i].Text)


		// increment virtual text cursor 
		if i == 2 {
			x = 0.0
			y = y - pixHSpan //* map.HackyHeightFraction)
		}else
		if i == 3 {
			x = x + pixHSpan
			x = x + pixHSpan
		}else{
			x = x + pixHSpan
		}
	}

	//s = s + "ROTATE Left  == LMB,  [LCtrl], [RAlt]\n"
	//s = s + "ROTATE Right == RMB,  [LAlt],  [RCtrl]\n"
}


func drawVirtualKeyBackdrops () {
	//"mouse" icon/s needed 
	//"mouse" icon/s needed 
	//"mouse" icon/s needed 

	if app.Mode == app.MODE_PLAYING {
		draw.SetColor4(draw.White, 0.8)
	}else{
		draw.SetColor3(draw.White)
	}
	var x f32 = -1.0 + SPAN_HALF
	var y f32 = -1.0 + SPAN_HALF_V
	
	// bottom 3 
	for i := 0; i < NUM_H_KEYS; i++ {
		sizedPicAt(PicShapeTile, 
			x,
			y, 
			SPAN, 
			SPAN * map.HackyHeightFraction)

		if i == 0 {
			sizedPicAt(PicArrowLeft, 
				x,
				y, 
				SPAN_HALF, 
				SPAN_HALF_V)
			sizedPicAt(PicMouse, 
				x + SPAN_QUARTER,
				y, 
				SPAN_QUARTER, 
				SPAN_QUARTER)			
		}else			
		if i == 1 {
			sizedPicAt(PicArrowDown, 
				x,
				y, 
				SPAN_HALF, 
				SPAN_HALF_V)
			sizedPicAt(PicMouse, 
				x,
				y + SPAN_QUARTER, 
				SPAN_QUARTER, 
				SPAN_QUARTER)			
		}else			
		if i == 2 {
			sizedPicAt(PicArrowRight, 
				x,
				y, 
				SPAN_HALF, 
				SPAN_HALF_V)
			sizedPicAt(PicMouse, 
				x - SPAN_QUARTER,
				y, 
				SPAN_QUARTER, 
				SPAN_QUARTER)			
		}
				
		x = f32.add(x, SPAN)
	}
	
	
	x = -1.0 + SPAN_HALF
	y = f32.add(y, SPAN * map.HackyHeightFraction)


	// top left 
	sizedPicAt(PicShapeTile, 
		x,
		y, 
		SPAN, 
		SPAN * map.HackyHeightFraction)
	sizedPicAt(PicRotLeft, 
		x,
		y, 
		SPAN_HALF, 
		SPAN_HALF_V)
	sizedPicAt(PicMouseLMB, 
		x + SPAN_QUARTER,
		y, 
		SPAN_QUARTER, 
		SPAN_QUARTER)			


	x = f32.add(x, SPAN * 2.0)

	
	// top right 
	sizedPicAt(PicShapeTile, 
		x,
		y, 
		SPAN, 
		SPAN * map.HackyHeightFraction)
	sizedPicAt(PicRotRight, 
		x,
		y, 
		SPAN_HALF, 
		SPAN_HALF_V)
	sizedPicAt(PicMouseRMB, 
		x - SPAN_QUARTER,
		y, 
		SPAN_QUARTER, 
		SPAN_QUARTER)			
}