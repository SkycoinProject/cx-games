package main

import "app"
import "draw"
import "gui"
import "inputs"
import "menu"
import "space"
import "tiles"



func gameInit () {
	app.START_WIDTH  = 590
	app.START_HEIGHT = 960
	app.Init("C X t r i s", getControlsText() )
	
	draw.Init()
	space.Init()
	menu.Init()

	inputs.BufferingNotchyDeltas = true
	inputs.Init(true)
	
	menuInit()
	shape.Init()
	drawInit()
	startNewGameSession()
}


func gameUpdate () {
	respondToKeyEvents()
	respondToButtonEvents()
	respondToPointerEvents()
	respondToNotchyMouseDeltas()
	
	if inputs.UserActionWithinLast(1.0D) {
		gui.ShowControls = false
	}
}


// game controls info 
func getControlsText () (s str) {
	s =     "MOVE         == mouse, [A], [S], [D], or arrow keys\n"
	s = s + "ROTATE Left  == LMB,   [Q], [LCtrl], [RAlt]\n"
	s = s + "ROTATE Right == RMB,   [E], [LAlt],  [RCtrl]\n"
}


func startNewGameSession () {
	inputs.LatestUserActionTime = 0.0D
	gui.ShowControls = true
	
	shape.Next = i32.rand(0, shape.SHAPE_MAX)
	tiles.EmptyPlayfield()
 	shape.SpawnNew()
	
	// spawn any wanted random debris blocks 
	for     y := 0; y < DebrisHeight; y++ {
		for x := 0; x < tiles.NUM_CELLS_X;   x++ {
			// use below condition for testing collapsing 4 rows @ a time 
			//x != 4 && y != 1 && y != 2 { 
			if i32.rand(0, 2) == 0 {
				tiles.Cells[y][x] = i32.rand(0, shape.SHAPE_MAX)
			}
		}
	}
}


func respondToKeyEvents () {
	var key    i32
	var action i32
	key, action = inputs.GetKeyEvent ()

	if action == glfw.Press {
		oneTimeOnly(key)
		repeaters(key)
	}else
	if action == glfw.Repeat { // (generated by keys that are held longer than ___) 
		repeaters(key)
	}else
	if action == glfw.Release {
	}
}


func oneTimeOnly (key i32) {
	if inputs.OpenedMenu(key) {
		startNewGameSession()
	}else
	if inputs.EventAbilityLeft(key) {
		shape.AttemptRotate(-1)
	}else
	if inputs.EventAbilityRight(key) {
		shape.AttemptRotate(1)			
	}else{
		inputs.CloseAppOnDeveloperShortcut(key)
	}
}


func repeaters (key i32) {
	var moved bool
	
	if app.Mode == app.MODE_PLAYING {
		if inputs.EventMoveLeft(key) {
			moved = shape.AttemptMoveByOffset(-1, 0)
		}else
		if inputs.EventMoveRight(key) {
			moved = shape.AttemptMoveByOffset(1, 0)
		}else
		if inputs.EventMoveUp(key) {
			// NO NEED TO MOVE UP 
		}else
		if inputs.EventMoveDown(key) {
			moved = shape.AttemptMoveByOffset(0, -1)
		}
	}
}


func respondToButtonEvents () {
	var button i32
	var action i32
	button, action = inputs.GetButtonEvent ()
		
	if action == glfw.Repeat { // (generated by buttons that are held longer than ___) 
	}else
	if action == glfw.Release {
	}else 
	if action == glfw.Press {
		if button == glfw.MouseButtonLeft {
			if app.Mode < app.MODE_MENU_MAX { // in a menu 
				respondToMenuClicks()
			}
			
			shape.AttemptRotate(-1)
		}else
		if button == glfw.MouseButtonRight {
			shape.AttemptRotate(1)
		}else 
		if button == glfw.MouseButtonMiddle {
		}
	}
}


func respondToNotchyMouseDeltas () {
	var v app.Vec2I = inputs.GetNotchyMouseDelta ()
	
	if v.X != app.MAX_I32 {
		if v.Y > 0 { // only allow moving shape down 
			v.Y = 0
		}
		
		var moved bool = shape.AttemptMoveByOffset(v.X, v.Y)
	}
}


func respondToPointerEvents () {
	var v app.Vec2 = inputs.GetPointerEvent ()
		
	// allow dragging a slider handle 
	if inputs.HoldingLeftButton && 
		v.X != app.TOO_BIG_F32 &&
		app.Mode <= app.MODE_MENU_OPTIONS {
			
		respondToMenuDrags()
	}
}


func respondToMenuDrags () {
	var s str
	var i i32
	s, i = menu.GetHoveredItem(app.Mode)

	/*
	if s == menu.ItemText {
		menu.Setting = menu.SetSliderValue(i, f64.f32(MousePosInPixels.X))
	} else
	*/
	if s == DebrisHeightText {
		DebrisHeight = menu.SetSliderValue(i, f64.f32(inputs.MousePosInPixels.X))
		startNewGameSession()
	} else
	if s == SpeedText {
		DropSpeed =    menu.SetSliderValue(i, f64.f32(inputs.MousePosInPixels.X))
		CalcDropTime()
	}
}


func respondToMenuClicks () {
	var s str
	var i i32
	s, i = menu.GetHoveredItem(app.Mode)

	if s == menu.Play {
		inputs.UseMousePointer(false)
		shape.PlayerScore    =  0
		shape.PlayerScoreTxt = "0"
		startNewGameSession()
		app.Mode = app.MODE_PLAYING
	} else
	if s == menu.Options {
		app.Mode = app.MODE_MENU_OPTIONS
	} else
	if s == menu.Controls {
		app.Mode = app.MODE_MENU_CONTROLS
	} else
	if s == menu.Quit {
		glfw.SetShouldClose(app.Name, true)
	} else
	if s == ShowNextShapeText + "YES" {
		    ShowNextShape = false
		menu.Items[app.Mode][i].Text = ShowNextShapeText + "NO"
	} else
	if s == ShowNextShapeText + "NO" {
		    ShowNextShape = true
		menu.Items[app.Mode][i].Text = ShowNextShapeText + "YES"
	}
}
