package main

import "app"
import "geom"



var numSnakes i32 = 5
var snakes  [][]app.Vec2I // 1st index is the snake id, 2nd is the segment (0 is the head) 
var fruits    []app.Vec2I



func entitiesInit () {
	fruits = append(
	fruits, getRandUnusedPos())
	
	var v []Vec2I
	  v = []Vec2I{}
	
	for i := 0; i < numSnakes; i++ {
		snakes = append(
		snakes, v)
		
		snakes[i] = append(
		snakes[i], getRandUnusedPos())
	}
}


var nextMove f32
func entitiesUpdate () {	
	if (nextMove < time.Now) {
		nextMove = time.Now + 0.15
		
		var ms bool
		
		// randomly move non-player snakes 
		for i := 1; i < len(snakes); i++ {
			var dir i32 = i32.rand(0, 4)
			ms = movedSnake(i, dir)
		}


		// player controlled snake 
		if inputs.HoldingGoLeft () {
			ms = movedSnake(0, geom.DIR_LEFT)
		}else
		if inputs.HoldingGoRight() {
			ms = movedSnake(0, geom.DIR_RIGHT)
		}else
		if inputs.HoldingGoDown () {
			ms = movedSnake(0, geom.DIR_DOWN)
		}else
		if inputs.HoldingGoUp   () {
			ms = movedSnake(0, geom.DIR_UP)
		}				
	}
}


func movedSnake (i i32, dir i32) (moved bool) {
	makeTailTrail(i)

	if dir == geom.DIR_LEFT {
		snakes[i][0].X = 
		snakes[i][0].X - 1
		
		if  snakes[i][0].X < 0 {
			snakes[i][0].X = 0
		}
	}else	
	if dir == geom.DIR_RIGHT {
		snakes[i][0].X = 
		snakes[i][0].X + 1
		
		if  snakes[i][0].X >= NUM_CELLS_ACROSS {
			snakes[i][0].X  = NUM_CELLS_ACROSS-1
		}
	}else	
	if dir == geom.DIR_DOWN {
		snakes[i][0].Y = 
		snakes[i][0].Y - 1
		
		if  snakes[i][0].Y < 0 {
			snakes[i][0].Y = 0
		}
	}else	
	if dir == geom.DIR_UP {
		snakes[i][0].Y = 
		snakes[i][0].Y + 1
		
		if  snakes[i][0].Y >= NUM_CELLS_ACROSS {
			snakes[i][0].Y  = NUM_CELLS_ACROSS-1
		}
	}
	
	// any fruits touched, grows the touching snake 
	for     f := 0; f < len(fruits); f++ {
		for s := 0; s < len(snakes); s++ {
			if  snakes[s][0].X == fruits[f].X &&
				snakes[s][0].Y == fruits[f].Y {
					
				fruits[f] = getRandUnusedPos()
				
				var n i32 = len(snakes[s])
				var v Vec2I
				  v = Vec2I{}
				v.X = snakes[s][n-1].X
				v.Y = snakes[s][n-1].Y
				
				snakes[s] = append(
				snakes[s], v)
			}
		}
	}
}


func makeTailTrail (s i32) {
	// "> 0" to skip 0 (head), cuz it moves (by it's OWN rules) rather than trailing \\
	var st i32 = len(snakes[s])-1 // issue report this (how it can't be in the 1st line of the for loop) 
	for i := st; i > 0; i-- {
		snakes[s][i].X = snakes[s][i-1].X
		snakes[s][i].Y = snakes[s][i-1].Y
	}
}


func getRandUnusedPos () (pos app.Vec2I) {
	pos.X = i32.rand(0, NUM_CELLS_ACROSS)
	pos.Y = i32.rand(0, NUM_CELLS_ACROSS)
	
	for cells[pos.Y][pos.X] != ENTITY_NONE {
		pos.X = i32.rand(0, NUM_CELLS_ACROSS)
		pos.Y = i32.rand(0, NUM_CELLS_ACROSS)
	}
}


