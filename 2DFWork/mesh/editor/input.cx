package ccInput

import "glfw"

import "app"
import "collision"
import "entity"
import "mesh"



var MousePointer    Vec2
var SnapToGrid      bool
var Dragging        bool
var DragStart       Vec2
var draggedLayerId  i32 // these 2 ids were when we could only drag 1... 
var draggedVertexId i32 // ...vert at a time.  probably useless now 

// keys 
var	GLFW_KEY_W      i32 = 87
var	GLFW_KEY_A      i32 = 65
var	GLFW_KEY_S      i32 = 83
var	GLFW_KEY_D      i32 = 68

var GLFW_KEY_SPACE  i32 = 32

//		temp camera control 
var GLFW_KEY_N      i32 = 78
var GLFW_KEY_Y      i32 = 89
var GLFW_KEY_F2     i32 = 291
var GLFW_KEY_F3     i32 = 292



func Setup () {
	str.print("input/ccInput.Setup()")

	Menus = []Menu{} // prep all menus 
	SetupMenu(EDIT_TOOLBAR, 8) // just 1 

	// callbacks 
	glfw.SetKeyCallback("window", "onKeyEvent")
	glfw.SetMouseButtonCallback("window", "onMouseButtonEvent")
	glfw.SetCursorPosCallback("window", "onCursorPosEvent")
}


func Update () {
	//str.print("input/ccInput.Update()")

	// motion input status 
	//moveLeft  = keyIsDown(GLFW_KEY_A)
	//moveRight = keyIsDown(GLFW_KEY_D)
	//moveUp    = keyIsDown(GLFW_KEY_W)
	//moveDown  = keyIsDown(GLFW_KEY_S)
	//str.print("call SetPlayerVelocity() causing prob")
}


func GoLeft() (out bool) {
	if i32.eq(glfw.GetKey("window", GLFW_KEY_A), 1) ||
		i32.eq(glfw.GetKey("window", GLFW_KEY_LEFT), 1) {
		out = true
	}
}
func GoRight() (out bool) {
	if i32.eq(glfw.GetKey("window", GLFW_KEY_D), 1) ||
		i32.eq(glfw.GetKey("window", GLFW_KEY_RIGHT), 1) {
		out = true
	}
}
func GoDown() (out bool) {
	if i32.eq(glfw.GetKey("window", GLFW_KEY_S), 1) ||
		i32.eq(glfw.GetKey("window", GLFW_KEY_DOWN), 1) {
		out = true
	}
}
func GoUp() (out bool) {
	if i32.eq(glfw.GetKey("window", GLFW_KEY_W), 1) ||
		i32.eq(glfw.GetKey("window", GLFW_KEY_UP), 1) {
		out = true
	}
}

func Back(key i32) (out bool) {
	if i32.eq(glfw.GetKey("window", GLFW_KEY_ESCAPE), 1) ||
		i32.eq(glfw.GetKey("window", GLFW_KEY_HOME), 1) {
		out = true
	}
}


// mouse buttons 
func onMouseButtonEvent (window str, button i32, action i32, mods i32) () {
	if action == 0 { // release 
		if button == 0 { // LMB 
			if Dragging {
				pickAllVertsInDragBox()
			}
			
			Dragging = false
		} else
		if button == 1 { // RMB 
		}
	} else if action == 1 { // press 
		//printf("onMouseButtonEvent() - %f, %f \n", MousePointer.X, MousePointer.Y)

		if button == 0 { // LMB 
			doPrimaryAction()
		} else { // RMB, MMB (would be unwise to require more than 3 buttons) 
			doSecondaryOrTertiaryAction(button)
		}
	}
}


func doSecondaryOrTertiaryAction(button i32) () {
	if app.Mode == app.APPMODE_EDITOR &&
		app.EditMode == app.EDITMODE_VERTICES ||
		app.EditMode == app.EDITMODE_TRIANGLES {
			
		var touchedVert bool
		var lId i32 // layer id 
		var i i32
		touchedVert, lId, i = getTouchedVertexNode(MousePointer)
		
		if button == 1 {
			str.print("RMB press && EDITMODE_VERTICES")
			doValidGridSpaceSecondary()
		} else
		if button == 2 {
			str.print("MMB press && EDITMODE_VERTICES")
			
			if touchedVert {			
				str.print("mesh.DeleteVertexNode(lId, i)")
			}
		}
	}
}


// mouse position 
var oldX f32
var oldY f32
var deltaX f32
var deltaY f32
func onCursorPosEvent (window str, x f64, y f64) () {
	oldX = MousePointer.X
	oldY = MousePointer.Y
	
	var mX f32
	mX = f32.div(f64.f32(x), i32.f32(app.ScreenSizeInPixels.X))
	mX = f32.mul(mX, f32.mul(f64.f32(collision.ScreenEdgeR), 2.0))
	MousePointer.X = f32.add(f64.f32(collision.ScreenEdgeL), mX)

	var mY f32
	mY = f32.div(f64.f32(y), i32.f32(app.ScreenSizeInPixels.Y))
	mY = f32.mul(mY, 2.0)
	MousePointer.Y = f32.sub(1.0, mY)
	
	deltaX = f32.sub(MousePointer.X, oldX)
	deltaY = f32.sub(MousePointer.Y, oldY)
	
	if Dragging {
		//mesh.EditLayers[draggedLayerId].Points[draggedVertexId].X = MousePointer.X
		//mesh.EditLayers[draggedLayerId].Points[draggedVertexId].Y = MousePointer.Y
		
		for j := 0; j < len(mesh.PickedVerts); j++ {
			var v i32
			v = mesh.PickedVerts[j]
			mesh.EditLayers[mesh.CurrLayer].Points[v].X = f32.add(
			mesh.EditLayers[mesh.CurrLayer].Points[v].X, deltaX)
			mesh.EditLayers[mesh.CurrLayer].Points[v].Y = f32.add(
			mesh.EditLayers[mesh.CurrLayer].Points[v].Y, deltaY)
		}
	}
	
	//printf("onCursorPosEvent %f, %f \n", MousePointer.X, MousePointer.Y)
}


// keys 
func onKeyEvent (window str, key i32, scancode i32, action i32, mods i32) () {
	// action == 0, release 
	// action == 1, press 
	// action == 2, is an autorepeat event, generated by keys that are held longer than a second

	if action != 2 { // (not a repeat) 
		if action == 1 { // (press) 
			//str.print("-------------------------------------PRESS (not a repeat)")

			//if key == 50 { // GLFW_KEY_2 
			//} else
			//if key == 51 { // GLFW_KEY_3 
			//} else
			if Back(key) {
				app.Mode = app.APPMODE_EDITOR
			} else
			if key == 53 { // GLFW_KEY_5 
				// close 
				str.print("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ QUITTING GAME ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^")
				glfw.SetShouldClose("window", true)
			} else
			if key == GLFW_KEY_SPACE {
				doPrimaryAction()
			}

			//maybeToggleMousePointer(key)
		}
	}
}


var wantMousePointer bool
func maybeToggleMousePointer (key i32) () {
	i32.print(key)

	if Back(key) ||
		key == 257 || // GLFW_KEY_ENTER
		key == 258 || // GLFW_KEY_TAB 
		key == 259 { // GLFW_KEY_BACKSPACE 

		str.print("DEF go to main menu")
		wantMousePointer = !wantMousePointer

		if bool.eq(wantMousePointer, true) {
			str.print("wantMousePointer TRUE")
			glfw.SetInputMode("window", glfw.Cursor, glfw.CursorNormal)
		} else {
			str.print("wantMousePointer FALSE")
			glfw.SetInputMode("window", glfw.Cursor, glfw.CursorDisabled)
		}
	}
}


func doPrimaryAction () () {
	//str.print("doPrimaryAction ()")
	var mode i32
	var pos  Vec2
	var vel  Vec2
	var ext  Vec2
	
	// handle modes 
	if app.Mode == app.APPMODE_PLAYING {
		pos = entity.Ents[0].Pos
		pos.X = f32.add(pos.X, entity.Ents[0].Extents.X)
		pos.X = f32.add(pos.X, entity.BulletExtents.X)
		pos.X = f32.add(pos.X, 0.03) // hero to bullet padding 
		vel = Vec2{ X: app.MAX_HERO_SPEED * 2.0, Y: 0.0 }
		mode = entity.ENTMODE_MOVING_STRAIGHT
		ext = entity.BulletExtents
	
		var ent Entity
		ent = Entity{ 
			Type: entity.TYPE_BULLET, 
			Pos: pos, 
			Vel: vel, 
			Mode: mode, 
			Extents: ext }
		
		entity.Add(ent)
	} else if app.Mode == app.APPMODE_EDITOR {
		doPrimaryAbility()
	}
}


func getTouchedMenuItem (mouse Vec2) (touched bool, id i32) {
	touched, id = getTouchedMenuItemFrom(EDIT_TOOLBAR, mouse)
	
	if app.EditMode == app.EDITMODE_MESH_PICKER {
		var mpTouched bool
		var mpId i32
		mpTouched, mpId = getTouchedMenuItemFrom(len(Menus) - 1, mouse)
		//printf("not utilizing yet - mpTouched: %v, mpId: %d \n", mpTouched, mpId)
		
		if mpTouched {
			mesh.EditLayers[mesh.CurrLayer] = mesh.RawMeshes[mpId]
			app.EditMode = app.EDITMODE_VERTICES
		}
	}
}


func getTouchedMenuItemFrom (menuId i32, mouse Vec2) (touched bool, id i32) {
	printf("menuId: %d \n", menuId)
	
	for i := 0; i32.lt(i, len(Menus[menuId].Items)); i++ {
		var p Vec2
		var e Vec2
		p = Menus[menuId].Items[i].Pos
		e = Menus[menuId].Items[i].Extents
		
		if collision.PointInBox(mouse, p, e) {			
			touched = true
			id = i			
			break
		}
	}
}


func getTouchedVertexNode (p Vec2) (touched bool, layId i32, vertId i32) {
	touched = false
	
	for li := 0; i32.lt(li, len(mesh.EditLayers)); li++ {
		for i := 0; i32.lt(i, len(mesh.EditLayers[li].Points)); i++ {
			var v Vec2
			v = mesh.EditLayers[li].Points[i]
			
			if collision.PointInBox(p, v, entity.NodeExtents) {			
				touched = true
				layId = li			
				vertId = i			
				break
			}
		}
	}
}
