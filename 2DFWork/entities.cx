package entities

import "app"
import "geom"
import "inputs"
import "mov"
import "space"
import "time"



// "enums"                     FIXME: when CX has enums or constants 
var ENT_PLAYER   i32
var ENT_2DFW_MAX i32 = 1

var ball         Entity     // FIXME: get rid of this hardwired carry-over player object 
var All          [][]Entity // all entities (except ball ATM: FIXME)  
var ActiveCounts []i32      // corresponds with "All" slices (len - NumActive == num recyclables) 

type Entity struct {
	x         f32
	y         f32
	vx        f32
	vy        f32
	gravity   f32
	
	Mode      i32
	Extents   app.Vec2
	WrapView  bool // moving objects wrap/teleport to opposite side of viewport 

	// FIXME: move these into Sky Taxi 
	GridPos   app.Vec2I
	// cell bounds/connections 
	CellMin   app.Vec2 // boundaries of the current cell it's in 
	CellMax   app.Vec2 // ^ 
	//Room    map.CarvedRoom // CAN'T FIGURE OUT WHY THIS MAKES AVATAR DISAPPEAR 
	ExitNorth bool
	ExitSouth bool
	ExitEast  bool
	ExitWest  bool
}



func Init (maxEntTypes i32) {
	str.print("entities.Init ()")
	
	// add all slices needed for entity types 
	var newEnts []Entity
	for i := 0; i < maxEntTypes; i++ {
		ents = []Entity{}
		All = append(
		All, newEnts)
		ActiveCounts = append(
		ActiveCounts, 0)
	}
	
	printf("    Created %v slices (1 for each entity type) \n", maxEntTypes)
}


// each app/game probably has a few unique entities that are 
// special cases, & updated uniquely at app level 
// (such as player objects, which might be the current falling 
// piece/shape in CXtris, or the player paddles/buckets in
// SkyBOOM). 
// SkyBOOM's coin dropping cloud is another example. 
// the rest can be handle generically, moving around based on 
// their current velocity. 
func Update () {
	//printf("entities.Update () \n")

	// velocity 
	//		player desired 
	mov.SetPlayerVelocityFromInput()
	
	// motion/position 
	//		hardwired player (FIXME) 
	ball.x = f32.add(ball.x, ball.vx * time.Delta)
	ball.y = f32.add(ball.y, ball.vy * time.Delta)
	//		all the rest 
	for     t := 0; t < len(All);        t++ {
		//printf("entities.Update () t:%d \n", t)
		
		for i := 0; i < ActiveCounts[t]; i++ {
			UpdateAt(t, i)
		}
	}
	
	// back out of any penetration (FIXME for "All") 
	mov.ConstrainPosByMap()
}


func InitPlayer () {
	var ex app.Vec2 // extents 
	ex =   app.Vec2{ 
		X: 0.05, 
		Y: 0.05}	

	ball = Entity{
		Extents: ex,
		x:       0.0,
		y:       0.0,
		vx:      0.0,
		vy:      0.0,
		gravity: 0.01}
}


func Spawn (eType i32, newEnt Entity) {
	//str.print("Spawn ()")

	var aC i32 // active count 
	aC = ActiveCounts[eType]

	var iC i32 // inclusive count (+ inactives)
	iC = len(All[eType])
	
	if  aC < iC /* (can recycle an inactive) */ { 
		str.print("------------- Spawn ()     aC & iC differ, RECYCLING 1st inactive")
		All[eType][aC].x        = newEnt.x
		All[eType][aC].y        = newEnt.y        
		All[eType][aC].vx       = newEnt.vx       
		All[eType][aC].vy       = newEnt.vy       
		All[eType][aC].gravity  = newEnt.gravity  
		All[eType][aC].Mode     = newEnt.Mode     
		All[eType][aC].Extents  = newEnt.Extents  
		All[eType][aC].WrapView = newEnt.WrapView	
	}else{
		str.print("------------- Spawn ()     appending")
		All[eType] = append(
		All[eType], newEnt)
	}

	printf("ActiveCounts[%d]: %d iC: %d BEFORE   \n", eType, ActiveCounts[eType], len(All[eType]))
	ActiveCounts[eType] = 
	ActiveCounts[eType] + 1
	printf("ActiveCounts[%d]: %d iC: %d FINISHED \n", eType, ActiveCounts[eType], len(All[eType]))
}


func Kill (eType i32, id i32) {
	var aC i32 // active count 
	aC = ActiveCounts[eType]

	var iC i32 // inclusive count (+ inactives)
	iC = len(All[eType])
	
	var lS i32 // last slot (of actives) 
	lS = aC - 1
	
	// the normal recycle process needs to operate on 2 slots. 
	// it copies the values of the 
	// last ActiveCounts slot to the slot being recycled 
	// (also prevents having an inactive slot which would have 
	// 		needed an extra var in order to be marked for skipping) 
	printf("(========== ABOUT TO copy values from lS: %v ---> id: %v    (aC: %v) \n", lS, id, aC)
	if  aC > 1  /* (has 2 slots for copying) */ && 
		id < lS /* (not last active, last needs no copy) */ {
			
		printf("RECYCLE  eType: %d   id: %d BEFORE \n", eType, id)
		All[eType][id].x        = All[eType][lS].x
		All[eType][id].y        = All[eType][lS].y
		All[eType][id].vx       = All[eType][lS].vx
		All[eType][id].vy       = All[eType][lS].vy
		All[eType][id].gravity  = All[eType][lS].gravity
		All[eType][id].Mode     = All[eType][lS].Mode
		All[eType][id].Extents  = All[eType][lS].Extents
		All[eType][id].WrapView = All[eType][lS].WrapView
		printf("RECYCLED eType: %d   id: %d        \n", eType, id)
		printf("(========== copied values from lS: %d ---> id: %d \n", lS, id)
	}

	printf("ActiveCounts[%d]: %d iC: %d BEFORE \n",   eType, ActiveCounts[eType], len(All[eType]))
	ActiveCounts[eType] = 
	ActiveCounts[eType] - 1
	printf("ActiveCounts[%d]: %d iC: %d FINISHED \n", eType, ActiveCounts[eType], len(All[eType]))
}


func GetCountOf (entType i32) (c i32) {
	c = ActiveCounts[entType]
}


func GetRect (entType i32, id i32) (t f32, r f32, b f32, l f32) {
	t = All[entType][id].y + All[entType][id].Extents.Y
	r = All[entType][id].x + All[entType][id].Extents.X
	b = All[entType][id].y - All[entType][id].Extents.Y
	l = All[entType][id].x - All[entType][id].Extents.X
}


func UpdateAt (et i32, i i32) { // entity type, id 
	if et != 4 {
		printf("entities.UpdateAt (et: %d    i: %d) \n", et, i)
	}
	
	All[et][i].x = f32.add(All[et][i].x, All[et][i].vx * time.Delta)
	All[et][i].y = f32.add(All[et][i].y, All[et][i].vy * time.Delta)
	
	if All[et][i].WrapView {
		if  All[et][i].x > space.ViewEdgeR + All[et][i].Extents.X {
			All[et][i].x = space.ViewEdgeL - All[et][i].Extents.X
		}else
		if  All[et][i].x < space.ViewEdgeL - All[et][i].Extents.X {
			All[et][i].x = space.ViewEdgeR + All[et][i].Extents.X
		}
		
		if  All[et][i].y >  1.0 + All[et][i].Extents.Y {
			All[et][i].y = -1.0 - All[et][i].Extents.Y
		}else
		if  All[et][i].y < -1.0 - All[et][i].Extents.Y {
			All[et][i].y =  1.0 + All[et][i].Extents.Y
		}
	}
}
