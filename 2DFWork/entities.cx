package entities

import "app"
import "geom"
import "inputs"
import "mov"
import "space"
import "time"



type Entity struct {
	x         f32
	y         f32
	vx        f32
	vy        f32
	gravity   f32
	
	Type      i32 // FIXME DELETE THIS, UNUSED!!!!!!!!! 
	Mode      i32
	Extents   app.Vec2
	WrapView  bool // moving objects wrap/teleport to opposite side of viewport 

	// FIXME: move these into Sky Taxi 
	GridPos   app.Vec2I
	// cell bounds/connections 
	CellMin   app.Vec2 // boundaries of the current cell it's in 
	CellMax   app.Vec2 // ^ 
	//Room    map.CarvedRoom // CAN'T FIGURE OUT WHY THIS MAKES AVATAR DISAPPEAR 
	ExitNorth bool
	ExitSouth bool
	ExitEast  bool
	ExitWest  bool
}

var ball Entity // FIXME: get rid of this hardwired carry-over player object 
var All  [][]Entity // all entities (except ball ATM: FIXME) 



func Init () {
	str.print("entities.Init ()")
}


// each app/game probably has a few unique entities that are 
// special cases, & updated uniquely at app level 
// (such as player objects, which might be the current falling 
// piece/shape in CXtris, or the player paddles/buckets in
// SkyBOOM). 
// SkyBOOM's coin dropping cloud is another example. 
// the rest can be handle generically, moving around based on 
// their current velocity. 
func Update () {
	//str.print("entities.Update ()")

	// velocity 
	//		player desired 
	mov.SetPlayerVelocityFromInput()
	
	// motion/position 
	//		hardwired player (FIXME) 
	ball.x = f32.add(ball.x, ball.vx * time.Delta)
	ball.y = f32.add(ball.y, ball.vy * time.Delta)
	
	//		all the rest 
	for     t := 0; t < len(All);    t++ {
		for i := 0; i < len(All[t]); i++ {
			UpdateAt(i, t)
		}
	}
	
	// back out of any penetration (FIXME for "All") 
	mov.ConstrainPosByMap()
}


func InitPlayer () {
	var ex app.Vec2 // extents 
	ex =   app.Vec2{ 
		X: 0.05, 
		Y: 0.05}	

	ball = Entity{
		Extents: ex,
		x:       0.0,
		y:       0.0,
		vx:      0.0,
		vy:      0.0,
		gravity: 0.01}
}


func GetLenOf (entType i32) (num i32) {
	num = len(All[entType])
}


func GetRect (entType i32, id i32) (t f32, r f32, b f32, l f32) {
	t = All[entType][id].y + All[entType][id].Extents.Y
	r = All[entType][id].x + All[entType][id].Extents.X
	b = All[entType][id].y - All[entType][id].Extents.Y
	l = All[entType][id].x - All[entType][id].Extents.X
}


func UpdateAt (i i32, et i32) { // entity type 
	//printf("slice: %d   -   %d \n", et, i)
	
	All[et][i].x = f32.add(All[et][i].x, All[et][i].vx * time.Delta)
	All[et][i].y = f32.add(All[et][i].y, All[et][i].vy * time.Delta)
	
	if All[et][i].WrapView {
		if  All[et][i].x > space.ViewEdgeR + All[et][i].Extents.X {
			All[et][i].x = space.ViewEdgeL - All[et][i].Extents.X
		}else
		if  All[et][i].x < space.ViewEdgeL - All[et][i].Extents.X {
			All[et][i].x = space.ViewEdgeR + All[et][i].Extents.X
		}
		
		if  All[et][i].y >  1.0 + All[et][i].Extents.Y {
			All[et][i].y = -1.0 - All[et][i].Extents.Y
		}else
		if  All[et][i].y < -1.0 - All[et][i].Extents.Y {
			All[et][i].y =  1.0 + All[et][i].Extents.Y
		}
	}
}
