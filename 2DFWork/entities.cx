package entities

import "app"
import "geom"
import "inputs"
import "map"
import "mov"
import "space"



type Entity struct {
	x         f32
	y         f32
	vx        f32
	vy        f32
	gravity   f32
	radius    f32
	
	GridPos   app.Vec2I
	// cell bounds/connections 
	CellMin   app.Vec2 // boundaries of the current cell it's in 
	CellMax   app.Vec2 // ^ 
	//Room    map.CarvedRoom // CAN'T FIGURE OUT WHY THIS MAKES AVATAR DISAPPEAR 
	ExitNorth bool
	ExitSouth bool
	ExitEast  bool
	ExitWest  bool
}

var ball Entity



func Init () {
	str.print("entities.Init ()")
	
	ball = Entity{
		radius:  0.05,
		x:       0.0,
		y:       0.0,
		vx:      0.0,
		vy:      0.0,
		gravity: 0.01}
		
	SetPlayerRoomBounds(i32.rand(0, map.GetNumCarvedOutRooms()))
}


func Update () {
	// velocity 
	//		player desired 
	mov.SetPlayerVelocityFromInput()
	
	// motion/position 
	ball.x = f32.add(ball.x, ball.vx)
	ball.y = f32.add(ball.y, ball.vy)


	// collision bounce 
	var gridDelta i32 // for player crossing boundaries into adjacent grid cells 
	
	gridDelta, ball.x, ball.vx = mov.BounceOffWalls(ball.x, ball.vx, ball.radius, 
		ball.CellMin.X, ball.CellMax.X, ball.ExitWest, ball.ExitEast) //space.ViewEdgeL, space.ViewEdgeR)
	
	if gridDelta != 0 {
		SetPlayerRoomBounds(map.Cells[ball.GridPos.Y][ball.GridPos.X + gridDelta].CarvedId)
	}

	
	gridDelta, ball.y, ball.vy = mov.BounceOffWalls(ball.y, ball.vy, ball.radius, 
		ball.CellMin.Y, ball.CellMax.Y, ball.ExitSouth, ball.ExitNorth) //-1.0D, 1.0D)

	if gridDelta != 0 {
		SetPlayerRoomBounds(map.Cells[ball.GridPos.Y + gridDelta][ball.GridPos.X].CarvedId)
	}

	// position correction 
	// 		when speed gets high enough, a simple velocity reversal isn't enough 
	// 		(jitters back & forth without getting back in bounds)
}


func SetPos (pos app.Vec2) {
	ball.x = pos.X
	ball.y = pos.Y
	//printf("SetPos () ball.x: %f \n", ball.x)
	//printf("SetPos () ball.y: %f \n", ball.y)
}


func SetPlayerRoomBounds (roomId i32) {
	printf("SetPlayerRoomBounds (roomId: %d) \n", roomId)
	var room CarvedRoom = map.GetRoom(roomId)
	ball.GridPos = room.Pos
	printf("setting ball.GridPos: %d,%d \n", ball.GridPos.X, ball.GridPos.Y)
	
	var minX f32 = i32.f32(room.Pos.X) * map.CellSpan
	var minY f32 = i32.f32(room.Pos.Y) * map.CellSpan
	
	var pos app.Vec2
	pos = app.Vec2{
		X: minX + map.CellSpanHalf, 
		Y: minY + map.CellSpanHalf}
	SetPos(pos)

	// set boundaries (for limiting collision checks) 
	ball.CellMin.X = minX + map.WTh
	ball.CellMin.Y = minY + map.WTh
	ball.CellMax.X = minX + map.CellSpan - map.WTh
	ball.CellMax.Y = minY + map.CellSpan - map.WTh
	//ball.Room      = room // CAN'T FIGURE OUT WHY THIS MAKES AVATAR DISAPPEAR 
	
	
	// setup connection flags/boundaries 	
	ball.ExitWest  = false
	ball.ExitEast  = false
	ball.ExitSouth = false
	ball.ExitNorth = false
	str.print("NEW room has exits in:")
	for i := 0; i < len(room.Exits); i++ {
		str.print(geom.GetTextForDir(room.Exits[i]))
		
		if room.Exits[i] == geom.DIR_LEFT  {
			ball.ExitWest = true
			ball.CellMin.X = minX
		}else
		if room.Exits[i] == geom.DIR_RIGHT {
			ball.ExitEast = true
			ball.CellMax.X = minX + map.CellSpan
		}else
		if room.Exits[i] == geom.DIR_DOWN  {
			ball.ExitSouth = true
			ball.CellMin.Y = minY
		}else
		if room.Exits[i] == geom.DIR_UP    {
			ball.ExitNorth = true
			ball.CellMax.Y = minY + map.CellSpan
		}
	}
}