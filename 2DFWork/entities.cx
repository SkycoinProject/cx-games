package entities

import "app"
import "geom"
import "inputs"
import "map"
import "mov"
import "space"



type Entity struct {
	x         f32
	y         f32
	vx        f32
	vy        f32
	gravity   f32
	radius    f32
	
	// cell bounds/connections 
	CellMin   app.Vec2 // boundaries of the current cell it's in 
	CellMax   app.Vec2 // ^ 
	//Room    map.CarvedRoom
	ExitNorth bool
	ExitSouth bool
	ExitEast  bool
	ExitWest  bool
}

var ball Entity



func Init () {
	str.print("entities.Init ()")
	
	ball = Entity{
		radius: 0.05,
		x: 0.0,
		y: 0.0,
		vx: 0.0,
		vy: 0.0,
		gravity: 0.01}
		
	putPlayerInRandomRoom()
}


func Update () {
	// velocity 
	//		player desired 
	mov.SetPlayerVelocityFromInput()
	
	// motion/position 
	ball.x = f32.add(ball.x, ball.vx)
	ball.y = f32.add(ball.y, ball.vy)

	//		by collision bounce 
	ball.x, ball.vx = mov.BounceOffWalls(ball.x, ball.vx, ball.radius, 
		ball.CellMin.X, ball.CellMax.X, ball.ExitWest, ball.ExitEast) //space.ViewEdgeL, space.ViewEdgeR)
	ball.y, ball.vy = mov.BounceOffWalls(ball.y, ball.vy, ball.radius, 
		ball.CellMin.Y, ball.CellMax.Y, ball.ExitSouth, ball.ExitNorth) //-1.0D, 1.0D)

	// position correction 
	// 		when speed gets high enough, a simple velocity reversal isn't enough 
	// 		(jitters back & forth without getting back in bounds)
}


func SetPos (pos app.Vec2) {
	ball.x = pos.X
	ball.y = pos.Y
	//printf("SetPos () ball.x: %f \n", ball.x)
	//printf("SetPos () ball.y: %f \n", ball.y)
}


func putPlayerInRandomRoom () {
	var rand i32 = i32.rand(0, map.GetNumCarvedOutRooms())
	var room CarvedRoom = map.GetRoom(rand)
	
	str.print("1st room has exits in:")
	for i := 0; i < len(room.Exits); i++ {
		str.print(geom.GetTextForDir(room.Exits[i]))
		
		if room.Exits[i] == geom.DIR_LEFT  {
			ball.ExitWest = true
		}else
		if room.Exits[i] == geom.DIR_RIGHT {
			ball.ExitEast = true
		}else
		if room.Exits[i] == geom.DIR_DOWN  {
			ball.ExitSouth = true
		}else
		if room.Exits[i] == geom.DIR_UP    {
			ball.ExitNorth = true
		}
	}
	
	var minX f32 = i32.f32(room.Pos.X) * map.CellSpan
	var minY f32 = i32.f32(room.Pos.Y) * map.CellSpan
	
	var pos app.Vec2
	pos = app.Vec2{
		X: minX + map.CellSpanHalf, 
		Y: minY + map.CellSpanHalf}
	SetPos(pos)

	// set boundaries (for limiting collision checks) 
	ball.CellMin.X = minX + map.WTh
	ball.CellMin.Y = minY + map.WTh
	ball.CellMax.X = minX + map.CellSpan - map.WTh
	ball.CellMax.Y = minY + map.CellSpan - map.WTh
	//ball.Room      = map.GetRoom(rand) //room
	
	//printf("putPlayerInRandomRoom ball.x: %f \n", ball.x)
	//printf("putPlayerInRandomRoom ball.y: %f \n", ball.y)
}