package space

import "app"



// FIXME: these should be updated from window change events 
var AspectRatio     f32 // horizontal FOV (field of view) NOT in degrees  
                        // vertical will always be 1.0, horizontal is relative to that 
var ViewWidInPixels i32 // separate values cuz *GetFramebuffer*() return format 
var ViewHeiInPixels i32
var ViewSizeInGL    app.Vec2
var PixelSize       app.Vec2 //           in GL space 
var ViewEdgeL       f64 // viewport left  in GL space 
var ViewEdgeR       f64 // viewport right in GL space 



func Init () {
	str.print("space.Init ()")
	
	ViewWidInPixels = app.START_WIDTH
	ViewHeiInPixels = app.START_HEIGHT
	PixelSize.X = 2.0 / i32.f32(app.START_WIDTH)
	PixelSize.Y = 2.0 / i32.f32(app.START_HEIGHT)
}


func Update (ratio f32) () {
	printf("space.Update () - ratio: %f \n", ratio)

	ViewEdgeL = f32.f64(f32.mul(ratio, -1.0))
	ViewEdgeR = f32.f64(ratio)

	printf("ViewEdgeL, ViewEdgeR: %f, %f \n", ViewEdgeL, ViewEdgeR)
}


func PointInBox (p Vec2, box Vec2, extents Vec2) (out bool) {
	if p.X > (box.X - extents.X) &&
		p.X < (box.X + extents.X) &&
		p.Y > (box.Y - extents.Y) &&
		p.Y < (box.Y + extents.Y) {
		
		out = true
	}
}


func BoxesOverlap (a Vec2, b Vec2, aExtents Vec2, bExtents Vec2) (out bool) {
	var padX f32 // minimum distance between centerpoints (before overlap occurs) 
	var padY f32
	var bX f32 // B's local position (in A's space) 
	var bY f32
	
	padX = f32.add(aExtents.X, bExtents.X)
	padY = f32.add(aExtents.Y, bExtents.Y)
	bX = f32.sub(b.X, a.X) 
	bY = f32.sub(b.Y, a.Y)
	
	if bX > padX {
		return false
	}
	
	if bX < -padX {
		return false
	}
	
	if bY > padY {
		return false
	}
	
	if bY < -padY {
		return false
	}
	
	return true
}
