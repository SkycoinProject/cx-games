package mov

/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
//////////////////////            ///////////////////
//////////////////////  MOVEMENT  ///////////////////
//////////////////////            ///////////////////
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////

import "app"
import "entities"
import "glfw"
import "map"
import "inputs"
import "time"



var Force f32 = 4.0



func SetPlayerVelocityFromInput () {
	entities.ball.vx = getVelocity(entities.ball.vx, inputs.HoldingGoLeft(), inputs.HoldingGoRight())
	entities.ball.vy = getVelocity(entities.ball.vy, inputs.HoldingGoDown(), inputs.HoldingGoUp())
}


func ConstrainPosByMap () {
	// collision bounce 
	var gridDelta i32 // for player crossing boundaries into adjacent grid cells 
	
	//		in X dimension 
	gridDelta, entities.ball.x, entities.ball.vx = BounceOffWalls(
		entities.ball.x, 
		entities.ball.vx, 
		entities.ball.ExtentX, 
		entities.ball.CellMin.X, 
		entities.ball.CellMax.X, 
		entities.ball.ExitWest, 
		entities.ball.ExitEast)
	
	if gridDelta != 0 {
		var x i32 = entities.ball.GridPos.X + gridDelta
		var y i32 = entities.ball.GridPos.Y
		map.SetPlayerRoomBounds(x, y, false)
	}

	
	//		in Y dimension 
	gridDelta, entities.ball.y, entities.ball.vy = BounceOffWalls(
		entities.ball.y, 
		entities.ball.vy, 
		entities.ball.ExtentY, 
		entities.ball.CellMin.Y, 
		entities.ball.CellMax.Y, 
		entities.ball.ExitSouth, 
		entities.ball.ExitNorth) //-1.0D, 1.0D)

	if gridDelta != 0 {
		var x i32 = entities.ball.GridPos.X
		var y i32 = entities.ball.GridPos.Y + gridDelta
		map.SetPlayerRoomBounds(x, y, false)
	}
}


// args: 
// position, velocity, radius, negative edge boundary, positive edge boundary, 
// exit in negative direction, exit in positive direction 
// returns: 
// gridDelta is the change to the current index into the "Cells" grid array. 
// (for when player crosses the boundary into an adjacent cell) 
func BounceOffWalls (pos f32, vel f32, rad f32, negEdge f32, posEdge f32, negExit bool, posExit bool) (gridDelta i32, outPos f32, outVel f32) {
	outPos = pos
	outVel = vel

	if vel < 0.0 {
		if negExit {
			if pos < negEdge {
				str.print("passed [-] threshold")
				gridDelta = -1
			}
		}else{
			if pos - rad < negEdge {
				outPos = f32.add(negEdge, rad)
				outVel = f32.abs(vel)
			}
		}
	}else
	if vel > 0.0 {
		if posExit {
			if pos >= posEdge {
				str.print("passed [+] threshold")
				gridDelta = 1
			}
		}else{
			if pos + rad >= posEdge {
				outPos = f32.sub(posEdge, rad)
				outVel = 0.0 - f32.abs(vel)
			}
		}
	}
}


func dampenNegativeMovement (velocity f32, strength f32) (out f32) {
	out = f32.add(velocity, Force * time.Delta * strength)

	if out > 0.0 {
		out = 0.0
	}
}


func dampenPositiveMovement (velocity f32, strength f32) (out f32) {
	out = f32.sub(velocity, Force * time.Delta * strength)

	if out < 0.0 {
		out = 0.0
	}
}


func getVelocity (velocity f32, negative bool, positive bool) (out f32) {
	out = velocity

	//____________________________________________ 
	if positive { // _________ speed up positively 
		if out < 0.0 {
			out = dampenNegativeMovement(out, 4.0)
		}

		out = f32.add(out, Force * time.Delta)
	} else
	if negative { // _________ speed up negatively 
		if out > 0.0 {
			out = dampenPositiveMovement(out, 4.0)
		}

		out = f32.sub(out, Force * time.Delta)
	} else { //_________________________ slow down 
		if out > 0.0 {
			out = dampenPositiveMovement(out, 1.0)
		} else
		if out < 0.0 {
			out = dampenNegativeMovement(out, 1.0)
		}
	}
}
