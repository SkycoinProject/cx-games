package main



func respondToPointerEvents () {
	var v app.Vec2 = inputs.GetPointerEvent ()
		
	if v.X != app.TOO_BIG_F32 &&
		app.Mode > app.MODE_MENU_MAX {
			
		var n i32 = entities.GetLenOf(plr)
		
		for i := 0; i < n; i++ {
			entities.All[plr][i].X = 
			entities.All[plr][i].X + inputs.MouseDeltaX
		}
	}
}


func respondToButtonEvents () {
	var button i32
	var action i32
	button, action = inputs.GetButtonEvent ()
		
	if action == glfw.Repeat { // (generated by buttons that are held longer than ___) 
	}else
	if action == glfw.Release {
	}else 
	if action == glfw.Press {
		if button == glfw.MouseButtonLeft {
			if app.Mode < app.MODE_MENU_MAX { // in a menu 
				respondToMenuClicks()
			}
			
			// do 
		}else
		if button == glfw.MouseButtonRight {
		}else 
		if button == glfw.MouseButtonMiddle {
		}
	}
}


func respondToKeyEvents () {
	var key    i32
	var action i32
	key, action = inputs.GetKeyEvent ()

	if action == glfw.Press {
		oneTimeOnly(key)
		repeaters(key)
	}else
	if action == glfw.Repeat { // (generated by keys that are held longer than ___) 
		repeaters(key)
	}else
	if action == glfw.Release {
	}
}


func oneTimeOnly (key i32) {
	if inputs.OpenedMenu(key) {
		inputs.UseMousePointer(true)
	}else{
		inputs.CloseAppOnDeveloperShortcut(key)
	}
}


func repeaters (key i32) {
	if app.Mode == app.MODE_PLAYING {
		if inputs.EventMoveLeft(key) {
		}else
		if inputs.EventMoveRight(key) {
		}else
		if inputs.EventMoveUp(key) {
		}else
		if inputs.EventMoveDown(key) {
		}else
		if inputs.EventAbilityLeft(key) {
		}else
		if inputs.EventAbilityRight(key) {
		}
	}
}
