package main

import "app"
import "entities"
import "inputs"

/*

--------------- ISSUE REPORTS ----------------------------------------
hmmmm, it seems i can't get the correct values out of a struct which was returned by a function from a package.  i guess all the values i retrieve from a package have to be basic types.

func Get (entType i32, id i32) (e Entity) {
  e = All[entType][id]
  printf("INSIDE Get() All[entType][id].y: %f \n", All[entType][id].y)
  printf("INSIDE Get()                e.y: %f \n", e.y)
}

that's INSIDE the package, and even INSIDE, "e" has default values instead of what i had just set it to.

(the All[entType][id].y has the values i expected)



------------------------------- SkyBOOM ------------------------------
--- SPLASH SCREEN 

Full Skycoin logo inc. text


--- INITIAL MENU 

whole background field of....
random sized, placed, angled, angular velocity coins 
	(try not only Z angles, but X or Y as well)
random color shading even?


--- GAMEPLAY BACKGROUND

smaller skycoin cloud logos in a band across upper half(?) of screen
		...kind of like a parallax starfield in space games 
	random sized, random scaled (diff in x & y), 
	random alpha value? 
	random blueness & grayness (from white base) 


--- DIFFICULTY SCALING FACTORS

dropper can keep getting lower
"        "  bounce up & down?
" can start throwing angles on coins
coins could come down in jiggly patterns or dodge slightly?
dropper move speed
drop rate
dropper changing direction more
total height of buckets
fall speed

*/

// misc 
var pTop        f32 // player top edge 
var explodeLine f32 // vertical pos that triggers explosion 



func gameInit () {
	app.     Init("S k y B O O M", "Move with mouse.")
	draw.    Init()
	inputs.  Init(true)
	entities.Init()
	
	// game specific 
	menuInit()
	drawInit()
	entitiesInit()
	
	explodeLine = -1.0 + coinExtents.Y
	pTop = entities.All[PLAYER][0].y +
		   entities.All[PLAYER][0].Extents.Y
	//printf("pTop: %f      [PLAYER][0].y: %f        [PLAYER][0].Extents.Y: %f \n", 
	//	pTop, entities.All[PLAYER][0].y, entities.All[PLAYER][0].Extents.Y)
}


func gameUpdate () {
	respondToPointerEvents()
	respondToButtonEvents()
	respondToKeyEvents()
	
	updateGameEntities()
}


func updateGameEntities () {
	// player 
	entities.All[PLAYER][0].x = inputs.MousePointer.X
	
	// 		cache edges 
	var pL f32 // left  
	var pR f32 // right 
	pL, pR = getPlayerEdges()
	
	// 		keep entirely within view 
	if pR > space.ViewEdgeR {
		entities.All[PLAYER][0].x = space.ViewEdgeR -
		entities.All[PLAYER][0].Extents.X
		pL, pR = getPlayerEdges()
	}else
	if pL < space.ViewEdgeL {
		entities.All[PLAYER][0].x = space.ViewEdgeL +
		entities.All[PLAYER][0].Extents.X
		pL, pR = getPlayerEdges()
	}
	
	
	dropperUpdate()
	
	
	// falling coin collisions 
	var et i32 = FALLING_COIN // entity type 
	var n  i32 = entities.GetLenOf(et)
	for i := n - 1; i >= 0; i-- { // go backwards for removals 
		var t f32 // rect edges 
		var r f32
		var b f32
		var l f32
		t, r, b, l = entities.GetRect(et, i)
		
		
		
		doFading(i)
		
		// collision 
		if b > 1.0 { // (above top of viewport) 
			killCoin(i)
		}else
		if b < explodeLine { // touched floor/detonators/whatev 
			killCoin(i)
		}else
		if b < pTop { // (below top of PLAYER bucket/s) 
			if  caughtCoin(i, pL, pR, l) { // coin left  edge 
				break // avoid catching twice 
			}
			
			var q bool
			q = caughtCoin(i, pL, pR, r)   // coin right edge 
		}
	}
}


func getPlayerEdges () (l f32, r f32) {
	l = // left 
		entities.All[PLAYER][0].x -
		entities.All[PLAYER][0].Extents.X
		
	r = // right 
		entities.All[PLAYER][0].x +
		entities.All[PLAYER][0].Extents.X
}


func killCoin (i i32) {
	entities.All[FALLING_COIN] = remove(
	entities.All[FALLING_COIN], i)
	printf("killed coin: %d \n", i)
}


func doFading (i i32) {
	if  entities.All[FALLING_COIN][i].Mode == MODE_FADING {
		entities.All[FALLING_COIN][i].Extents.X = 
		entities.All[FALLING_COIN][i].Extents.X + time.Delta
		entities.All[FALLING_COIN][i].Extents.Y = 
		entities.All[FALLING_COIN][i].Extents.Y + time.Delta
	}
}


// detect edge touching player 
func caughtCoin (i i32, pL f32, pR f32, edge f32) (out bool) {
	if  edge < pR &&
		edge > pL {
			
		entities.All[FALLING_COIN][i].Mode = MODE_FADING
		entities.All[FALLING_COIN][i].vx = edge * -0.5
		entities.All[FALLING_COIN][i].vy = 2.6 // fly up 
		//printf("coin < pTop: %f   %d \n", pTop, i)
		return true
	}
	
	return false
}
