package main

import "app"
import "entities"
import "inputs"



var coinRadius      f32 = 0.045 // while dropping 
var pTop            f32     // player top edge 
var explodeLine     f32 = -1.0 + coinRadius // vertical pos that triggers explosion 
// entities 
var /* new...*/ ent entities.Entity
//		"enums" of unique entities at beginning of entities.All 
var PLAYER          i32
var DROPPER         i32 = 1 // coin DROPPER 
var MAX_UNIQUES     i32 = 2 // how many special cases listed above 
//		modes 
var MODE_DROPPING   i32
var MODE_FADING     i32 = 1
// dropper reverse logic 
var reverseTarget   f32
var numTargetGrains i32 = 100
var nextDrop        f32
var dropDelay       f32 = 0.3



func gameInit () {
	app.Init("S k y B O O M", "Move with mouse.")
	draw.Init()
	inputs.Init(true)
	entities.Init()
	
	drawInit()
	
	// entities 
	// 		PLAYER 
	ent = entities.Entity{ radius: 0.2, y: -1.0 }
	entities.All = append(
	entities.All, ent)
	
	// 		DROPPER 
	ent = entities.Entity{ radius: 0.1, y:  1.0, vx: 1.2 }
	entities.All = append(
	entities.All, ent)
	
	pTop = entities.All[PLAYER].y +
		   entities.All[PLAYER].radius

	setReverseTarget()
}


func gameUpdate () {
	respondToPointerEvents()
	respondToButtonEvents()
	respondToKeyEvents()
	
	updateGameEntities()
}


func handleDropperReversing () {
	if     entities.All[DROPPER].vx < 0.0 {
		// going left 
		if entities.All[DROPPER].x < reverseTarget {
			reverseDropper()
		}else
		if entities.All[DROPPER].x < f64.f32(space.ViewEdgeL) {
			reverseDropper()
		}
	}else{
		// going right 
		if entities.All[DROPPER].x > reverseTarget {
			reverseDropper()
		}else
		if entities.All[DROPPER].x > f64.f32(space.ViewEdgeR) {
			reverseDropper()
		}
	}
}


func reverseDropper () {
	var vX f32 = entities.All[DROPPER].vx
	entities.All[DROPPER].vx = -vX
	setReverseTarget()
}


func setReverseTarget () {
	var pd f32 // potential distance 

	if entities.All[DROPPER].vx > 0.0 { 
		// going right 
		pd = f32.sub(f64.f32(space.ViewEdgeR), entities.All[DROPPER].x)
	}else{ 
		// going left 
		pd = f32.sub(f64.f32(space.ViewEdgeL), entities.All[DROPPER].x)
	}

	printf("potential distance: %f \n", pd)
	
	var targetGrainSize f32 = f32.div(pd, i32.f32(numTargetGrains))
	var r i32 = i32.rand(0, numTargetGrains)
	reverseTarget = f32.mul(i32.f32(r), targetGrainSize)
	//printf("targetGrainSize: %f \n", targetGrainSize)
}


func respondToPointerEvents () {
	var pos app.Vec2
		
	for pos.X != app.TOO_BIG_F32 {
		pos = inputs.GetPointerEvent()
		//printf("x,y: %f,%f \n", pos.X, pos.Y)
	}
}


func respondToButtonEvents () {
	var button i32
	var action i32
	button, action = inputs.GetButtonEvent ()
		
	if action == glfw.Repeat { // (generated by buttons that are held longer than ___) 
	}else
	if action == glfw.Release {
	}else 
	if action == glfw.Press {
		if button == glfw.MouseButtonLeft {
			if app.Mode <= app.MODE_MENU_OPTIONS { // in a menu 
				respondToMenuClicks()
			}
			
			// do 
		}else
		if button == glfw.MouseButtonRight {
		}else 
		if button == glfw.MouseButtonMiddle {
		}
	}
}


func respondToKeyEvents () {
	var key    i32
	var action i32
	key, action = inputs.GetKeyEvent ()

	if action == glfw.Press {
		oneTimeOnly(key)
		repeaters(key)
	}else
	if action == glfw.Repeat { // (generated by keys that are held longer than ___) 
		repeaters(key)
	}else
	if action == glfw.Release {
	}
}


func oneTimeOnly (key i32) {
	if inputs.OpenedMenu(key) {
	}else{
		inputs.CloseAppOnDeveloperShortcut(key)
	}
}


func repeaters (key i32) {
	if app.Mode == app.MODE_PLAYING {
		if inputs.EventLeft(key) {
		} else
		if inputs.EventRight(key) {
		} else
		if inputs.EventUp(key) {
		} else
		if inputs.EventDown(key) {
		} else
		if inputs.EventRotateLeft(key) {
		} else
		if inputs.EventRotateRight(key) {
		}
	}
}


func respondToMenuClicks () {
}


func updateGameEntities () {
	// player 
	entities.All[PLAYER].x = inputs.MousePointer.X
	
	var pL f32 =  // player left  edge 
		entities.All[PLAYER].x -
		entities.All[PLAYER].radius
		
	var pR f32 = // player right edge 
		entities.All[PLAYER].x +
		entities.All[PLAYER].radius
	
	// dropper 
	entities.UpdateAt(DROPPER)
	handleDropperReversing()
	dropCoins()
	
	// common 
	var n i32 = entities.GetNumOfAll()
	for i := n - 1; i >= MAX_UNIQUES; i-- { // go backwards for removals 
		var e Entity = entities.All[i]
		doFading(i)
		
		// collision 
		if e.y > 1.0 { // (above top of viewport) 
			killEntity(i)
		}else
		if e.y < explodeLine { // touched floor 
			killEntity(i)
		}else
		if e.y < pTop + e.radius { // (below top of PLAYER bucket/s) 
			if  caughtCoin(e, i, pL, pR, e.x - e.radius) { // coin left  edge 
				break // avoid catching twice 
			}
			
			var b bool
			b = caughtCoin(e, i, pL, pR, e.x + e.radius)   // coin right edge 
		}
	}
}


func killEntity (i i32) {
	entities.All = remove(
	entities.All, i)
	printf("killed entity: %d \n", i)
}


func doFading (i i32) {
	if  entities.All[i].Mode == MODE_FADING {
		entities.All[i].radius = 
		entities.All[i].radius + time.Delta
	}
}


// detect edge touching player 
func caughtCoin (e Entity, i i32, pL f32, pR f32, edge f32) (out bool) {
	if  edge < pR &&
		edge > pL {
			
		entities.All[i].Mode = MODE_FADING
		entities.All[i].vx = e.x * -0.05
		entities.All[i].vy = 2.6 // fly up 
		//printf("coin < pTop: %f   %d \n", pTop, i)
		return true
	}
	
	return false
}


func dropCoins () {	
	if nextDrop <= time.Now {
		nextDrop = time.Now + dropDelay
		//str.print("drop\n")
		
		ent = entities.Entity{ 
			radius:  coinRadius, 
			x:       entities.All[DROPPER].x,
			y:       0.9, 
			vx:      0.0,
			vy:     -1.2 }
		entities.All = append(
		entities.All, ent)
	}
}