package main

import "app"
import "entities"
import "inputs"

/*

--- SPLASH SCREEN 

Full Skycoin logo inc. text


--- INITIAL MENU 

whole background field of....
random sized, placed, angled, angular velocity coins 
	(try not only Z angles, but X or Y as well)
random color shading even?


--- GAMEPLAY BACKGROUND

smaller skycoin cloud logos in a band across upper half(?) of screen
		...kind of like a parallax starfield in space games 
	random sized, random scaled (diff in x & y), 
	random alpha value? 
	random blueness & grayness (from white base) 


--- DIFFICULTY SCALING FACTORS

dropper can keep getting lower
"        "  bounce up & down?
" can start throwing angles on coins
coins could come down in jiggly patterns or dodge slightly?
dropper move speed
drop rate
dropper changing direction more
total height of buckets
fall speed

*/

// misc 
var coinRadius      f32 = 0.045 // while dropping 
var pTop            f32         // player top edge 
var explodeLine     f32 = -1.0 + coinRadius // vertical pos that triggers explosion 
// entities 
var /* new...*/ ent entities.Entity
//		"enums" of unique entities at beginning of entities.All 
var PLAYER          i32
var DROPPER         i32 = 1 // coin DROPPER 
var MAX_UNIQUES     i32 = 2 // how many special cases listed above 
//		modes 
var MODE_DROPPING   i32
var MODE_FADING     i32 = 1



func gameInit () {
	app.     Init("S k y B O O M", "Move with mouse.")
	draw.    Init()
	inputs.  Init(true)
	entities.Init()
	
	menuInit()
	drawInit()
	
	// entities 
	// 		PLAYER 
	var r f32 =  0.2
	var y f32 = -1.0 + r
	ent = entities.Entity{ radius: r, y: y }
	entities.All = append(
	entities.All, ent)
	
	pTop = entities.All[PLAYER].y +
		   entities.All[PLAYER].radius
		   
	dropperInit()
	spawnCloudsBackdrop()
	spawnMenuCoinsBackdrop() // last, so we can skip them during gameplay 
}


func gameUpdate () {
	respondToPointerEvents()
	respondToButtonEvents()
	respondToKeyEvents()
	
	updateGameEntities()
}


func updateGameEntities () {
	// player 
	entities.All[PLAYER].x = inputs.MousePointer.X
	
	// 		cache edges 
	var pL f32 // left  
	var pR f32 // right 
	pL, pR = getPlayerEdges()
	
	// 		keep entirely within view 
	if pR > space.ViewEdgeR {
		entities.All[PLAYER].x = space.ViewEdgeR -
		entities.All[PLAYER].radius
		pL, pR = getPlayerEdges()
	}else
	if pL < space.ViewEdgeL {
		entities.All[PLAYER].x = space.ViewEdgeL +
		entities.All[PLAYER].radius
		pL, pR = getPlayerEdges()
	}
	
	
	// dropper 
	entities.UpdateAt(DROPPER)
	handleDropperReversing()
	dropCoins()
	
	
	// falling coins 
	var n i32 = entities.GetNumOfAll()
	for i := n - 1; i >= MAX_UNIQUES; i-- { // go backwards for removals 
		var e Entity = entities.All[i]
		doFading(i)
		
		if e.Type != FALLING_COIN {
			continue
		}
		
		// collision 
		if e.y > 1.0 { // (above top of viewport) 
			killEntity(i)
		}else
		if e.y < explodeLine { // touched floor 
			killEntity(i)
		}else
		if e.y < pTop + e.radius { // (below top of PLAYER bucket/s) 
			if  caughtCoin(e, i, pL, pR, e.x - e.radius) { // coin left  edge 
				break // avoid catching twice 
			}
			
			var b bool
			b = caughtCoin(e, i, pL, pR, e.x + e.radius)   // coin right edge 
		}
	}
}


func getPlayerEdges () (l f32, r f32) {
	l =  // left 
		entities.All[PLAYER].x -
		entities.All[PLAYER].radius
		
	r = // right 
		entities.All[PLAYER].x +
		entities.All[PLAYER].radius
}


func killEntity (i i32) {
	entities.All = remove(
	entities.All, i)
	//printf("killed entity: %d \n", i)
}


func doFading (i i32) {
	if  entities.All[i].Mode == MODE_FADING {
		entities.All[i].radius = 
		entities.All[i].radius + time.Delta
	}
}


// detect edge touching player 
func caughtCoin (e Entity, i i32, pL f32, pR f32, edge f32) (out bool) {
	if  edge < pR &&
		edge > pL {
			
		entities.All[i].Mode = MODE_FADING
		entities.All[i].vx = e.x * -0.05
		entities.All[i].vy = 2.6 // fly up 
		//printf("coin < pTop: %f   %d \n", pTop, i)
		return true
	}
	
	return false
}
