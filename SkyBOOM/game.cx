package main

import "app"
import "entities"
import "inputs"

/*

--------------- ISSUE REPORTS ----------------------------------------
passing parameter to entities.Update () had no proper error 




printf() can have more arguments than there is %codes for 




len() should give an error message when used on non-collection vars 




i seem to be having a problem with remove() not being able to selectively remove 1 item from a slice within a slice of slices.  just wondering if you ever do that @d2bug

it seems to remove all of them instead of just the 1.

entities.All[FALLING_COIN] = remove(entities.All[FALLING_COIN], i)

actually it seems to remove all items the 1st time or 2, then after that it leaves 1 (out of around 7 items) remaining in the inner slice.




hmmmm, it seems i can't get the correct values out of a struct which was returned by a function from a package.  i guess all the values i retrieve from a package have to be basic types.

func Get (entType i32, id i32) (e Entity) {
  e = All[entType][id]
  printf("INSIDE Get() All[entType][id].y: %f \n", All[entType][id].y)
  printf("INSIDE Get()                e.y: %f \n", e.y)
}

that's INSIDE the package, and even INSIDE, "e" has default values instead of what i had just set it to.

(the All[entType][id].y has the values i expected)






------------------------------- SkyBOOM notes ----------------------------
--- SPLASH SCREEN 

Full Skycoin logo inc. text


--- INITIAL MENU 

whole background field of....
random sized, placed, angled, angular velocity coins 
	(try not only Z angles, but X or Y as well)
random color shading even?


--- GAMEPLAY BACKGROUND

smaller skycoin cloud logos in a band across upper half(?) of screen
		...kind of like a parallax starfield in space games 
	random sized, random scaled (diff in x & y), 
	random alpha value? 
	random blueness & grayness (from white base) 


--- DIFFICULTY SCALING FACTORS

dropper can keep getting lower
"        "  bounce up & down?
" can start throwing angles on coins
coins could come down in jiggly patterns or dodge slightly?
dropper move speed
drop rate
dropper changing direction more
total height of buckets
fall speed

*/

// misc 
var plr  i32 = entities.ENT_PLAYER
var pTop f32 // player top edge 



func gameInit () {
	app.   Init("S k y B O O M", "Move with mouse.")
	draw.  Init()
	inputs.Init(true)
	
	// game specific 
	menuInit()
	drawInit()
	entitiesInit()
	
	pTop = entities.All[plr][0].y +
		   entities.All[plr][0].Extents.Y
	//printf("pTop: %f      [plr][0].y: %f        [plr][0].Extents.Y: %f \n", 
	//	pTop, entities.All[plr][0].y, entities.All[plr][0].Extents.Y)
}


func gameUpdate () {
	respondToPointerEvents()
	respondToButtonEvents()
	respondToKeyEvents()
	
	updateGameEntities()
}


func updateGameEntities () {
	// player 
	entities.All[plr][0].x = inputs.MousePointer.X
	
	// 		cache edges 
	var pL f32 // left  
	var pR f32 // right 
	pL, pR = getPlayerEdges()
	
	// 		keep entirely within view 
	if pR > space.ViewEdgeR {
		entities.All[plr][0].x = space.ViewEdgeR -
		entities.All[plr][0].Extents.X
		pL, pR = getPlayerEdges()
	}else
	if pL < space.ViewEdgeL {
		entities.All[plr][0].x = space.ViewEdgeL +
		entities.All[plr][0].Extents.X
		pL, pR = getPlayerEdges()
	}
	
	
	dropperUpdate()
	
	
	// falling coin collisions 
	var et i32 = FALLING_COIN // entity type 
	var n  i32 = entities.GetCountOf(et)
	var st i32 = n - 1
	printf("st: %v       n: %v \n", st, n)
	for i := st; i >= 0; i-- { // go backwards for removals 
		var t f32 // rect edges 
		var r f32
		var b f32
		var l f32
		t, r, b, l = entities.GetRect(et, i)
		printf("i: %d       b: %f \n", i, b)
		
		doFading(i)
		
		// collision 
		if b > 1.0 { // (above top of viewport) 
			printf("ABOUT TO Kill   *** EXITED TOP *** i: %d \n", i)
			entities.Kill(et, i)
		}else
		if b < -1.0 { // touched floor/detonators/whatev 
			printf("ABOUT TO Kill   *** EXITED BOTTOM *** i: %d \n", i)
			entities.Kill(et, i)
		}else
		if b < pTop { // (below top of plr bucket/s) 
			if      caughtCoin(i, pL, pR, l) { // coin left  edge 
				//break // avoid catching twice 
			}else{
				var u /* (unused return) */ bool
				u = caughtCoin(i, pL, pR, r)   // coin right edge 
			}
		}
	}
}


func getPlayerEdges () (l f32, r f32) {
	l = // left 
		entities.All[plr][0].x -
		entities.All[plr][0].Extents.X
		
	r = // right 
		entities.All[plr][0].x +
		entities.All[plr][0].Extents.X
}


func doFading (i i32) {
	if  entities.All[FALLING_COIN][i].Mode == MODE_FADING {
		entities.All[FALLING_COIN][i].Extents.X = 
		entities.All[FALLING_COIN][i].Extents.X + time.Delta
		entities.All[FALLING_COIN][i].Extents.Y = 
		entities.All[FALLING_COIN][i].Extents.Y + time.Delta
	}
}


// detect edge touching player 
func caughtCoin (i i32, pL f32, pR f32, edge f32) (out bool) {
	if  edge < pR &&
		edge > pL {
			
		entities.All[FALLING_COIN][i].Mode = MODE_FADING
		entities.All[FALLING_COIN][i].vx = edge * -0.5
		entities.All[FALLING_COIN][i].vy = 2.6 // fly up 
		//printf("coin < pTop: %f   %d \n", pTop, i)
		return true
	}
	
	return false
}
