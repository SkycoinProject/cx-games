package main



var coinExtent      f32 = 0.07 // (while dropping) 
// "enums" 
var DROPPER         i32 = entities.ENT_MAX_OF_2DFW     // coin DROPPER 
var FALLING_COIN    i32 = entities.ENT_MAX_OF_2DFW + 1
var BACKDROP_COIN   i32 = entities.ENT_MAX_OF_2DFW + 2 // for menu backdrop 
var BACKDROP_CLOUD  i32 = entities.ENT_MAX_OF_2DFW + 3 // gameplay backdrop 
var ENT_MAX_OF_GAME i32 = entities.ENT_MAX_OF_2DFW + 4
// modes 
var MODE_DROPPING   i32
var MODE_FADING     i32 = 1



func entitiesInit () {
	entities.Init(ENT_MAX_OF_GAME)
	entities.AutoUpdatePlayers = false
	var f f32 = 0.2
	entities.All[entities.ENT_PLAYER][0].y       = f - 1.0
	entities.All[entities.ENT_PLAYER][0].ExtentX = f
	entities.All[entities.ENT_PLAYER][0].ExtentY = f
	
	dropperInit()		   
	spawnCloudsBackdrop()
	spawnMenuBackdropCoins()
}


func entitiesUpdate () {
	// player 
	entities.All[plr][0].x = inputs.MousePointer.X
	
	// 		cache edges 
	var pL f32 // left  
	var pR f32 // right 
	pL, pR = getPlayerEdges()
	
	// 		keep entirely within view 
	if pR > space.ViewEdgeR {
		entities.All[plr][0].x = space.ViewEdgeR -
		entities.All[plr][0].ExtentX
		pL, pR = getPlayerEdges()
	}else
	if pL < space.ViewEdgeL {
		entities.All[plr][0].x = space.ViewEdgeL +
		entities.All[plr][0].ExtentX
		pL, pR = getPlayerEdges()
	}
	
	
	dropperUpdate()
	
	
	// falling coin collisions 
	var et i32 = FALLING_COIN // entity type 
	var n  i32 = entities.GetCountOf(et)
	var st i32 = n - 1
	printf("st: %v       n: %v \n", st, n)
	for i := st; i >= 0; i-- { // go backwards for removals 
		var t f32 // rect edges 
		var r f32
		var b f32
		var l f32
		t, r, b, l = entities.GetRect(et, i)
		printf("i: %d       b: %f \n", i, b)
		
		doFading(i)
		
		// collision 
		if b > 1.0 { // (above top of viewport) 
			printf("ABOUT TO Kill   *** EXITED TOP *** i: %d \n", i)
			entities.Kill(et, i)
		}else
		if b < -1.0 { // touched floor/detonators/whatev 
			printf("ABOUT TO Kill   *** EXITED BOTTOM *** i: %d \n", i)
			entities.Kill(et, i)
		}else
		if b < pTop { // (below top of plr bucket/s) 
			if      caughtCoin(i, pL, pR, l) { // coin left  edge 
				//break // avoid catching twice 
			}else{
				var u /* (unused return) */ bool
				u = caughtCoin(i, pL, pR, r)   // coin right edge 
			}
		}
	}
}


func spawnMenuBackdropCoins () {
	/*
	for     y < 1.0 {
		for x < space.ViewEdgeR {
			var ex app.Vec2   // extents 
			ex =   app.Vec2{ 
				X: randExt, 
				Y: randExt}	
			var startX f32 = space.ViewEdgeL - randExt
			var x f32 = startX
			var y f32 = -0.8
			var incX f32 = f32.mul(randExt, 2.0) * 1.33 // 1/3 ratio gap tween them 
			var incY f32 = f32.mul(randExt, 2.0) * 0.83
			
			ent = entities.Entity{
				Type: BACKDROP_COIN,
				x: x, 
				y: y, 
				vx: y, 
				//vy: -0.1, 
				Extents: ex, 
				WrapView: true }
			entities.Spawn(BACKDROP_COIN, ent)
			
			x = x + incX
		}	

		x = startX
		y = y + incY
	}	
	*/
}


func spawnCloudsBackdrop () {
	// extents 
	var exX f32 = 0.07 * cloudAspectRatio
	var exY f32 = 0.07
	
	var startX f32 = space.ViewEdgeL - exX
	var x f32 = startX
	var y f32 = 0.15
	var incX f32 = f32.mul(exX, 2.0) * 1.0 // 1.33 // 1/3 ratio gap tween them 
	var incY f32 = f32.mul(exY, 2.0) * 0.83
	
	for     y < entities.All[DROPPER][0].y -
		        entities.All[DROPPER][0].ExtentY {
		        	
		for x < space.ViewEdgeR {
			ent = entities.Entity{
				x:        x, 
				y:        y, 
				ExtentX:  y * exX, 
				ExtentY:  y * exY, 
				vx:       y, 
				//vy:     -0.1, 
				WrapView: true}
				
			entities.Spawn(BACKDROP_CLOUD, ent)
			
			x = x + incX
		}	

		x = startX
		y = y + incY
	}
}