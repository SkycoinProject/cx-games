package main



var coinExtent         f32 = 0.07 // (while dropping) 

// "enums"   FIXME: when CX has enums or constants 
var ENT_DROPPER        i32 = entities.ENT_MAX_OF_2DFW     // coin ENT_DROPPER 
var ENT_GAME_COIN      i32 = entities.ENT_MAX_OF_2DFW + 1
var ENT_BACKDROP_COIN  i32 = entities.ENT_MAX_OF_2DFW + 2 // for menu backdrop 
var ENT_BACKDROP_CLOUD i32 = entities.ENT_MAX_OF_2DFW + 3 // gameplay backdrop 
var ENT_PARTICLE_0     i32 = entities.ENT_MAX_OF_2DFW + 4
var ENT_PARTICLE_1     i32 = entities.ENT_MAX_OF_2DFW + 5
var ENT_MAX_OF_GAME    i32 = entities.ENT_MAX_OF_2DFW + 6
// 		modes 
var ENT_MODE_DROPPING  i32 = entities.ENT_MODE_MAX_OF_2DFW
var ENT_MODE_FADING    i32 = entities.ENT_MODE_MAX_OF_2DFW + 1



func entitiesInit () {
	entities.Init(ENT_MAX_OF_GAME)
	playerEntsInit()
	dropperInit()		   
	spawnCloudsBackdrop()
	spawnMenuBackdropCoins()
}


func entitiesUpdate () {
	entities.Update()
	
	if app.Mode < app.MODE_MENU_MAX {
		str.print("in menu")
		//return ///////// return does nothing?! ///////////////////////
		// (but func works as desired ATM, 
		// cuz the rest is in the "else" block) 
	}else{
	playerEntsUpdate()
	dropperUpdate()	
	
	// game coin collisions 
	var et i32 = ENT_GAME_COIN // entity type 
	var n  i32 = entities.GetCountOf(et)
	var st i32 = n - 1
	//printf("st: %v       n: %v \n", st, n)
	for i := st; i >= 0; i-- { // go backwards for removals 
		var t f32 // rect edges 
		var r f32
		var b f32
		var l f32
		t, r, b, l = entities.GetRect(et, i)
		//printf("i: %d       entities.All[et][i].WrapView: %v      b: %f \n", i, entities.All[et][i].WrapView, b)
		
		doFading(i)
		
		// collision 
		if b > 1.0 { // (above top of viewport) 
			entities.Kill(et, i)
		}else
		if b < -1.0 { // touched floor/detonators/whatev 
			// change coin dir, size, fade 
			entities.All[et][i].Mode = ENT_MODE_FADING
			entities.All[et][i].VelY = 2.6 // fly up 
			
			// remove 1 player paddle/wallet 
			var numP /* (paddles) */ i32 = entities.GetCountOf(plr)
			entities.Kill(plr, numP - 1)
			    numP                     = entities.GetCountOf(plr)
					
			// maybe end game 
			if numP < 1 {
				app.Mode = app.MODE_GAME_OVER
			}else{
				printf("numP - 1: %d \n", numP - 1)
				pT = entities.All[plr][numP - 1].Y +
					 entities.All[plr][numP - 1].ExtentY
			}
		}else{
			if  b < pT && // (below top of player bucket/s) 
				t > pB {

				if     caughtCoin(i, pL, pR, l) { // coin left  edge 
						score = score + 1
						spawnParticlePuffFrom(et, i)
						entities.Kill(et, i)
				}else{
					if caughtCoin(i, pL, pR, r) { // coin right edge 
						score = score + 1
						spawnParticlePuffFrom(et, i)
						entities.Kill(et, i)
					}
				}
			}
		}
	}
	}
}


var nTic /* new particle */ entities.Entity
func spawnParticlePuffFrom (et i32 /* entity type */, i i32) {
	for id := 0; id < 8; id++ {
		var r   i32 = i32.rand(-100, 100)
		var gX  f32 = f32.mul(0.01, i32.f32(r)) // goal offset 
		    r       = i32.rand(11, 250)
		var gY  f32 = f32.mul(0.01, i32.f32(r))
		var exp f32 = f32.add(time.Now, 0.9)
		
		nTic = entities.Entity{
			Mode:        entities.ENT_MODE_MOVING_TO_POS,
			GoalEntType: plr,
			GoalEntId:   0,
			GoalX:       entities.All[et][i].X + gX,
			GoalY:       entities.All[et][i].Y + gY,
			X:           entities.All[et][i].X, 
			Y:           entities.All[et][i].Y, 
			VelX:        gX * 0.2, 
			VelY:        gY * 0.2,
			ExtentX:     0.015, 
			ExtentY:     0.03,
			ExpiryTime:  exp}				
		
		if i32.rand(0, 2) == 0 {
			entities.Spawn(ENT_PARTICLE_0, nTic)
		}else{
			entities.Spawn(ENT_PARTICLE_1, nTic)
		}
	}
}


func spawnMenuBackdropCoins () {
	for i := 0; i < 250; i++ {
		// random extents 
		var irX i32 = i32.rand(16, 128)
		var irY i32 = i32.rand(16, 128)
		var ex  f32 = f32.mul(i32.f32(irX), space.PixelSize.X)

		// random pos 
		irX = i32.rand(0, space.ViewWidInPixels)
		irY = i32.rand(0, space.ViewHeiInPixels)
		var frX f32 = f32.add(space.ViewEdgeL, f32.mul(i32.f32(irX), space.PixelSize.X))
		var frY f32 = f32.add(-1.0           , f32.mul(i32.f32(irY), space.PixelSize.Y))
			
		ent = entities.Entity{
			X:        frX, 
			Y:        frY, 
			VelX:     frX * 0.2,
			VelY:     frY * 0.2,
			ExtentX:  ex, 
			ExtentY:  ex, 
			WrapView: true}
			
		entities.Spawn(ENT_BACKDROP_COIN, ent)
	}	
}


func spawnCloudsBackdrop () {
	// extents 
	var exX f32 = 0.07 * cloudAspectRatio
	var exY f32 = 0.07
	
	var startX f32 = space.ViewEdgeL - exX
	var x f32 = startX
	var y f32 = 0.15
	var incX f32 = f32.mul(exX, 2.0) * 1.0 // 1.33 // 1/3 ratio gap tween them 
	var incY f32 = f32.mul(exY, 2.0) * 0.83
	
	for     y < entities.All[ENT_DROPPER][0].Y -
		        entities.All[ENT_DROPPER][0].ExtentY {
		        	
		for x < space.ViewEdgeR {
			ent = entities.Entity{
				X:        x, 
				Y:        y, 
				ExtentX:  y * exX, 
				ExtentY:  y * exY, 
				VelX:     y, 
				//VelY:   -0.1, 
				WrapView: true}
				
			entities.Spawn(ENT_BACKDROP_CLOUD, ent)
			
			x = x + incX
		}	

		x = startX
		y = y + incY
	}
}