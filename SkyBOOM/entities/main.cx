package main



var coinExtent        f32 = 0.07 // (while dropping) 

// "enums" 
var ENT_DROPPER        i32 = entities.ENT_MAX_OF_2DFW     // coin ENT_DROPPER 
var ENT_GAME_COIN      i32 = entities.ENT_MAX_OF_2DFW + 1
var ENT_BACKDROP_COIN  i32 = entities.ENT_MAX_OF_2DFW + 2 // for menu backdrop 
var ENT_BACKDROP_CLOUD i32 = entities.ENT_MAX_OF_2DFW + 3 // gameplay backdrop 
var ENT_PARTICLE_0     i32 = entities.ENT_MAX_OF_2DFW + 4
var ENT_PARTICLE_1     i32 = entities.ENT_MAX_OF_2DFW + 5
var ENT_MAX_OF_GAME    i32 = entities.ENT_MAX_OF_2DFW + 6
// 		modes 
var ENT_MODE_DROPPING  i32
var ENT_MODE_FADING    i32 = 1



func entitiesInit () {
	entities.Init(ENT_MAX_OF_GAME)
	playerEntsInit()
	dropperInit()		   
	spawnCloudsBackdrop()
	spawnMenuBackdropCoins()
}


func entitiesUpdate () {
	entities.Update()
	playerEntsUpdate()
	dropperUpdate()	
	
	// game coin collisions 
	var et i32 = ENT_GAME_COIN // entity type 
	var n  i32 = entities.GetLenOf(et)
	var st i32 = n - 1
	//printf("st: %v       n: %v \n", st, n)
	for i := st; i >= 0; i-- { // go backwards for removals 
		var t f32 // rect edges 
		var r f32
		var b f32
		var l f32
		t, r, b, l = entities.GetRect(et, i)
		//printf("i: %d       entities.All[et][i].WrapView: %v      b: %f \n", i, entities.All[et][i].WrapView, b)
		
		doFading(i)
		
		// collision 
		if b > 1.0 { // (above top of viewport) 
			printf("ABOUT TO Kill   *** EXITED TOP *** i: %d \n", i)
			entities.Kill(et, i)
		}else
		if b < -1.0 { // touched floor/detonators/whatev 
			printf("ABOUT TO spawnParticlePuffFrom(et: %v, i: %v) GetLenOf: %v \n", et, i, entities.GetLenOf(et))
			spawnParticlePuffFrom(et, i)
			printf("ABOUT TO Kill   *** EXITED BOTTOM *** i: %d \n", i)
			entities.Kill(et, i)
		}else{
			if  b < pT && // (below top of plr bucket/s) 
				t > pB {

				if      caughtCoin(i, pL, pR, l) { // coin left  edge 
				}else{
					var u /* (unused return) */ bool
					u = caughtCoin(i, pL, pR, r)   // coin right edge 
				}
			}
		}
	}
}


var nTic /* new particle */ entities.Entity
func spawnParticlePuffFrom (et i32 /* entity type */, i i32) {
	for id := 0; id < 8; id++ {
		var r   i32 = i32.rand(-100, 100)
		var v   f32 = f32.mul(0.01, i32.f32(r))
		var exp f32 = f32.add(time.Now, 0.3)
		
		nTic = entities.Entity{
			x:          entities.All[et][i].x, 
			y:          entities.All[et][i].y, 
			vx:         v,
			vy:         2.4,
			ExtentX:    0.015, 
			ExtentY:    0.03,
			ExpiryTime: exp}				
		
		if i32.rand(0, 2) == 0 {
			entities.Spawn(ENT_PARTICLE_0, nTic)
		}else{
			entities.Spawn(ENT_PARTICLE_1, nTic)
		}
	}
}


func spawnMenuBackdropCoins () {
	for i := 0; i < 250; i++ {
		// random extents 
		var irX i32 = i32.rand(16, 128)
		var irY i32 = i32.rand(16, 128)
		var ex  f32 = f32.mul(i32.f32(irX), space.PixelSize.X)

		// random pos 
		irX = i32.rand(0, space.ViewWidInPixels)
		irY = i32.rand(0, space.ViewHeiInPixels)
		var frX f32 = f32.add(space.ViewEdgeL, f32.mul(i32.f32(irX), space.PixelSize.X))
		var frY f32 = f32.add(-1.0           , f32.mul(i32.f32(irY), space.PixelSize.Y))
			
		ent = entities.Entity{
			x:        frX, 
			y:        frY, 
			vx:       frX * 0.2,
			vy:       frY * 0.2,
			ExtentX:  ex, 
			ExtentY:  ex, 
			WrapView: true}
			
		entities.Spawn(ENT_BACKDROP_COIN, ent)
	}	
}


func spawnCloudsBackdrop () {
	// extents 
	var exX f32 = 0.07 * cloudAspectRatio
	var exY f32 = 0.07
	
	var startX f32 = space.ViewEdgeL - exX
	var x f32 = startX
	var y f32 = 0.15
	var incX f32 = f32.mul(exX, 2.0) * 1.0 // 1.33 // 1/3 ratio gap tween them 
	var incY f32 = f32.mul(exY, 2.0) * 0.83
	
	for     y < entities.All[ENT_DROPPER][0].y -
		        entities.All[ENT_DROPPER][0].ExtentY {
		        	
		for x < space.ViewEdgeR {
			ent = entities.Entity{
				x:        x, 
				y:        y, 
				ExtentX:  y * exX, 
				ExtentY:  y * exY, 
				vx:       y, 
				//vy:     -0.1, 
				WrapView: true}
				
			entities.Spawn(ENT_BACKDROP_CLOUD, ent)
			
			x = x + incX
		}	

		x = startX
		y = y + incY
	}
}