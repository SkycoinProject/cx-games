package main



var coinExtent        f32 = 0.07 // (while dropping) 

// "enums" 
var DROPPER         i32 = entities.ENT_MAX_OF_2DFW     // coin DROPPER 
var FALLING_COIN    i32 = entities.ENT_MAX_OF_2DFW + 1
var BACKDROP_COIN   i32 = entities.ENT_MAX_OF_2DFW + 2 // for menu backdrop 
var BACKDROP_CLOUD  i32 = entities.ENT_MAX_OF_2DFW + 3 // gameplay backdrop 
var ENT_MAX_OF_GAME i32 = entities.ENT_MAX_OF_2DFW + 4
// 		modes 
var MODE_DROPPING   i32
var MODE_FADING     i32 = 1



func entitiesInit () {
	entities.Init(ENT_MAX_OF_GAME)
	playerEntsInit()
	dropperInit()		   
	spawnCloudsBackdrop()
	spawnMenuBackdropCoins()
}


func entitiesUpdate () {
	entities.Update()
	playerEntsUpdate()
	dropperUpdate()	
	
	// falling coin collisions 
	var et i32 = FALLING_COIN // entity type 
	var n  i32 = entities.GetLenOf(et)
	var st i32 = n - 1
	//printf("st: %v       n: %v \n", st, n)
	for i := st; i >= 0; i-- { // go backwards for removals 
		var t f32 // rect edges 
		var r f32
		var b f32
		var l f32
		t, r, b, l = entities.GetRect(et, i)
		//printf("i: %d       b: %f \n", i, b)
		
		doFading(i)
		
		// collision 
		if b > 1.0 { // (above top of viewport) 
			printf("ABOUT TO Kill   *** EXITED TOP *** i: %d \n", i)
			entities.Kill(et, i)
		}else
		if b < -1.0 { // touched floor/detonators/whatev 
			//printf("ABOUT TO Kill   *** EXITED BOTTOM *** i: %d \n", i)
			entities.Kill(et, i)
		}else{
			if  b < pT && // (below top of plr bucket/s) 
				t > pB {

				if      caughtCoin(i, pL, pR, l) { // coin left  edge 
				}else{
					var u /* (unused return) */ bool
					u = caughtCoin(i, pL, pR, r)   // coin right edge 
				}
			}
		}
	}
}


func spawnMenuBackdropCoins () {
	for i := 0; i < 250; i++ {
		// random extents 
		var irX i32 = i32.rand(0, 64)
		var irY i32 = i32.rand(0, 64)
		var exX f32 = f32.mul(i32.f32(irX), space.PixelSize.X)
		var exY f32 = f32.mul(i32.f32(irY), space.PixelSize.Y)

		// random pos 
		irX = i32.rand(0, space.ViewWidInPixels)
		irY = i32.rand(0, space.ViewHeiInPixels)
		var frX f32 = f32.add(space.ViewEdgeL, f32.mul(i32.f32(irX), space.PixelSize.X))
		var frY f32 = f32.add(-1.0           , f32.mul(i32.f32(irY), space.PixelSize.Y))
			
		ent = entities.Entity{
			x:        frX, 
			y:        frY, 
			vx:       frY * 0.1,
			vy:       frY * 0.1,
			ExtentX:  exX, 
			ExtentY:  exY, 
			WrapView: true}
			
		entities.Spawn(BACKDROP_COIN, ent)
	}	
}


func spawnCloudsBackdrop () {
	// extents 
	var exX f32 = 0.07 * cloudAspectRatio
	var exY f32 = 0.07
	
	var startX f32 = space.ViewEdgeL - exX
	var x f32 = startX
	var y f32 = 0.15
	var incX f32 = f32.mul(exX, 2.0) * 1.0 // 1.33 // 1/3 ratio gap tween them 
	var incY f32 = f32.mul(exY, 2.0) * 0.83
	
	for     y < entities.All[DROPPER][0].y -
		        entities.All[DROPPER][0].ExtentY {
		        	
		for x < space.ViewEdgeR {
			ent = entities.Entity{
				x:        x, 
				y:        y, 
				ExtentX:  y * exX, 
				ExtentY:  y * exY, 
				vx:       y, 
				//vy:     -0.1, 
				WrapView: true}
				
			entities.Spawn(BACKDROP_CLOUD, ent)
			
			x = x + incX
		}	

		x = startX
		y = y + incY
	}
}